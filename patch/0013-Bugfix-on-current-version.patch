From 3ce9f3846a7963a3c9d1d218acec026595fde7ed Mon Sep 17 00:00:00 2001
From: MartinChoo <214582617@qq.com>
Date: Mon, 13 Oct 2025 18:40:10 +0800
Subject: [PATCH] Bugfix on current version

---
 ext/misc/cksumvfs.c |  11 +-
 src/compressvfs.c   | 352 +++++++++++++++++++++++++++++++-------------
 src/sqlite3.c       | 334 ++++++++++++++++++++++++++++++++++-------
 3 files changed, 529 insertions(+), 168 deletions(-)

diff --git a/ext/misc/cksumvfs.c b/ext/misc/cksumvfs.c
index 27b1028..e89edcd 100644
--- a/ext/misc/cksumvfs.c
+++ b/ext/misc/cksumvfs.c
@@ -559,17 +559,17 @@ static int cksmRead(
     **    (1) the size indicates that we are dealing with a complete
     **        database page, only support pageSize:4K
     **    (2) checksum verification is enabled
-    **    (3) we are not in the middle of checkpoint
+    **    (3) Skip the WAL log write, it might write segment as iSyncPoint, do checksum at checkpoint
     **    (4) magic number should be 0xff
     **    (5) checksum type should be 1, 0 means without checksum
     */
-    if( iAmt==4096           /* (1) */
+    if( iAmt==4096          /* (1) */
      && p->verifyCksm       /* (2) */
-     && !p->inCkpt          /* (3) */
+     && !p->isWal           /* (3) */
     ){
       if( ((u8*)zBuf)[iAmt-CKSUMVFS_RESERVED_SIZE]!=CKSUMVFS_MAGIC_NUM ){ /* (4) */
         sqlite3_log(SQLITE_IOERR_DATA, "unrecognized format, offset %lld of \"%s\", amt:%d", iOfst, p->zFName, iAmt);
-        return SQLITE_IOERR_DATA;
+        return rc;
       }
       if( ((u8*)zBuf)[iAmt-CKSUMVFS_RESERVED_SIZE+1]==CKSUMVFS_WITHOUT_CHECKSUM ){ /* (5) */
         return rc;
@@ -584,7 +584,6 @@ static int cksmRead(
         EncodeReservedBytesIntoBase16(cksum, CKSUMVFS_CHECKSUM_SIZE, actual, CKSUM_HEX_LEN);
         sqlite3_log(SQLITE_IOERR_DATA, "checksum fault offset %lld of \"%s\", amt:%d, expect:%s, actual:%s",
            iOfst, p->zFName, iAmt, expect, actual);
-        rc = SQLITE_IOERR_DATA;
       }
     }
   }
@@ -617,7 +616,7 @@ static int cksmWrite(
   */
   if( iAmt==4096
    && p->computeCksm
-   && !p->inCkpt
+   && !p->isWal
   ){
     ((u8*)zBuf)[iAmt-CKSUMVFS_RESERVED_SIZE]=CKSUMVFS_MAGIC_NUM;
     ((u8*)zBuf)[iAmt-CKSUMVFS_RESERVED_SIZE+1]=p->verifyCksm ? CKSUMVFS_CALC_CHECKSUM : CKSUMVFS_WITHOUT_CHECKSUM;
diff --git a/src/compressvfs.c b/src/compressvfs.c
index f2fe169..a29bdc3 100644
--- a/src/compressvfs.c
+++ b/src/compressvfs.c
@@ -151,6 +151,7 @@ typedef INT8_TYPE i8;              /* 1-byte signed integer */
 typedef u32 Pgno;
 /* VFS's name */
 #define COMPRESS_VFS_NAME "compressvfs"
+#define CKSM_VFS_NAME "cksmvfs"
 
 /* COMPRESSION OPTIONS */
 #define COMPRESSION_UNDEFINED 0
@@ -162,6 +163,8 @@ typedef u32 Pgno;
 #define SQLITE_SHMMAP_IS_WRITE       0x00000001  /* Flag for xShmMap, extend file if necessary */
 #define SQLITE_OPEN_COMPRESS_SHM     0x00010000  /* Flag for xShmMap, need to rename shm file */
 
+#define SQLITE_WARNING_DUMP          (SQLITE_WARNING | (2<<8))
+
 /* An open file */
 typedef struct{
   sqlite3_file base;        /* IO methods */
@@ -170,8 +173,10 @@ typedef struct{
   u8 bSubDbOpen;            /* True to SubDB is opened */
   u8 bBegin;                /* True to xSync() need commit */
   u8 compression;           /* Compression options */
-  int page_size;            /* Uncompressed page size */
+  int pageSize;             /* Uncompressed page size */
   int persistWalFlag;       /* Flag to persist flag */
+  int openFlags;            /* Flag to open file */
+  sqlite3_file *pLockFd;    /* File handle to lock file */
 } CompressFile;
 
 
@@ -233,7 +238,24 @@ typedef enum{
   BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT = 3,
 } BrotliDecoderResult;
 
-typedef BROTLI_BOOL (*brotliCompress_ptr)(u32, u32, size_t, const u8*, size_t*, u8*);
+/** Options for ::BROTLI_PARAM_MODE parameter. */
+typedef enum BrotliEncoderMde {
+  /**
+   * Default compression mode.
+   *
+   * In this mode compressor does not know anything in advance about the
+   * properties of the input.
+   */
+  BROTLI_MODE_GENERIC = 0,
+  /** Compression mode for UTF-8 formatted text input. */
+  BROTLI_MODE_TEXT = 1,
+  /** Compression mode used in WOFF 2.0 */
+  BROTLI_MODE_FONT = 2
+} BrotliEncoderMde;
+/** Default value for ::BROTLI_PARAM_MODE parameter. */
+#define BROTLI_DEFAULT_MODE BROTLI_MODE_GENERIC
+
+typedef BROTLI_BOOL (*brotliCompress_ptr)(int, int, BrotliEncoderMde, size_t, const u8*, size_t*, u8*);
 typedef BrotliDecoderResult (*brotliDecompress_ptr)(size_t, const u8*, size_t*, u8*);
 /*----------------------------brotli header end----------------------------*/
 
@@ -380,6 +402,7 @@ static int compressBuf(
     int ret = brotliCompressPtr(
       3,                        // COMPRESS QUALITY (1-11)
       BROTLI_MAX_WINDOW_BITS,   // WINDOWS SIZE (10-24)
+      BROTLI_DEFAULT_MODE,      // MODE(BROTLI_MODE_GENERIC, TEXT, FONT)
       (size_t)src_len,
       (const u8 *)src,
       &dst_len,
@@ -434,19 +457,22 @@ EXPORT_SYMBOLS int decompressBuf(
 }
 
 /* Check whether the table exists in the OutterDB. */
-static int tableExists(sqlite3 *db, const char *table_name){
+static int tableExists(sqlite3 *db, const char *table_name, u8 *isExist){
   sqlite3_stmt *stmt = NULL;
   const char *sql = "SELECT 1 FROM sqlite_master WHERE type='table' AND name=?;";
-  int exists = 0;
 
-  if( sqlite3_prepare_v2(db, sql, -1, &stmt, NULL)==SQLITE_OK ){
-    sqlite3_bind_text(stmt, 1, table_name, -1, SQLITE_STATIC);
-    if( sqlite3_step(stmt)==SQLITE_ROW ){
-      exists = 1;
-    }
-    sqlite3_finalize(stmt);
+  int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
+  if( rc!=SQLITE_OK ){
+    return rc;
+  }
+  sqlite3_bind_text(stmt, 1, table_name, -1, SQLITE_STATIC);
+  rc = sqlite3_step(stmt);
+  sqlite3_finalize(stmt);
+  if( rc!=SQLITE_ROW && rc!=SQLITE_DONE ){
+    return rc;
   }
-  return exists;
+  *isExist = (rc==SQLITE_ROW) ? 1 : 0;
+  return SQLITE_OK;
 }
 
 /* Get page size before compressed from OutterDB. */
@@ -504,15 +530,15 @@ static void getCompression(sqlite3 *db, CompressFile *pCompress){
   sqlite3_stmt *stmt = NULL;
   const char *sql = "SELECT count(*), compression, pagesize FROM vfs_compression;";
   int count = 0;
-  pCompress->compression = COMPRESSION_UNDEFINED;
-  pCompress->page_size = 0;
+  pCompress->compression = COMPRESSION_ZSTD;
+  pCompress->pageSize = 0;
 
   if( sqlite3_prepare_v2(db, sql, -1, &stmt, NULL)==SQLITE_OK ){
     if( sqlite3_step(stmt)==SQLITE_ROW ){
       count = sqlite3_column_int(stmt, 0);
       if( count==1 ){
         pCompress->compression = sqlite3_column_int(stmt, 1);
-        pCompress->page_size = sqlite3_column_int(stmt, 2);
+        pCompress->pageSize = sqlite3_column_int(stmt, 2);
       }
     }
     sqlite3_finalize(stmt);
@@ -590,7 +616,9 @@ static int compressDeviceCharacteristics(sqlite3_file *pFile){
 */
 static int compressLock(sqlite3_file *pFile, int eFileLock){
   assert( pFile );
-  return SQLITE_OK;
+  CompressFile *pCompress = (CompressFile *)pFile;
+  sqlite3_file *pSubFile = ORIGFILE(pFile);
+  return pSubFile->pMethods->xLock(pCompress->pLockFd, eFileLock);
 }
 
 /*
@@ -598,7 +626,9 @@ static int compressLock(sqlite3_file *pFile, int eFileLock){
 */
 static int compressUnlock(sqlite3_file *pFile, int eFileLock){
   assert( pFile );
-  return SQLITE_OK;
+  CompressFile *pCompress = (CompressFile *)pFile;
+  sqlite3_file *pSubFile = ORIGFILE(pFile);
+  return pSubFile->pMethods->xUnlock(pCompress->pLockFd, eFileLock);
 }
 
 /*
@@ -608,11 +638,11 @@ static int compressFileSize(sqlite3_file *pFile, i64 *pSize){
   assert( pFile );
   CompressFile *pCompress = (CompressFile *)pFile;
   sqlite3 *db = pCompress->pDb;
-  int rc = getCompressPgsize(db, &pCompress->page_size);
+  int rc = getCompressPgsize(db, &pCompress->pageSize);
   if( rc!=SQLITE_OK ){
     return SQLITE_IOERR_FSTAT;
   }
-  int pgsize = pCompress->page_size;
+  int pgsize = pCompress->pageSize;
   int maxpgno = getMaxCompressPgno(db);
   *pSize = (i64)maxpgno * pgsize;
   return SQLITE_OK;
@@ -625,11 +655,11 @@ static int compressTruncate(sqlite3_file *pFile, sqlite_int64 size){
   assert( pFile );
   CompressFile *pCompress = (CompressFile *)pFile;
   sqlite3 *db = pCompress->pDb;
-  int rc = getCompressPgsize(db, &pCompress->page_size);
-  if( rc!=SQLITE_OK || pCompress->page_size==0 ){
+  int rc = getCompressPgsize(db, &pCompress->pageSize);
+  if( rc!=SQLITE_OK || pCompress->pageSize==0 ){
     return SQLITE_IOERR_TRUNCATE;
   }
-  int pgsize = pCompress->page_size;
+  int pgsize = pCompress->pageSize;
   int pgno = size / pgsize;
   if( size % pgsize!=0 || getMaxCompressPgno(db) < pgno ){
     return SQLITE_IOERR_TRUNCATE;
@@ -661,58 +691,72 @@ static int compressWrite(sqlite3_file *pFile, const void *pBuf, int iAmt, sqlite
   assert( iAmt>0 );
   CompressFile *pCompress = (CompressFile *)pFile;
   sqlite3 *db = pCompress->pDb;
-  int rc = getCompressPgsize(db, &pCompress->page_size);
+  int rc = getCompressPgsize(db, &pCompress->pageSize);
   if( rc!=SQLITE_OK ){
+    sqlite3_log(SQLITE_WARNING_DUMP, "Missing pgsz(%d), write ofst:%lld, iAmt:%d, flags:%d", pCompress->pageSize,
+      iOfst, iAmt, pCompress->openFlags);
     return SQLITE_IOERR_WRITE;
   }
 
-  if( pCompress->page_size<=0 && iAmt >= 512 && iAmt <= 64*1024 && !(iAmt & (iAmt - 1)) ){
+  if( pCompress->pageSize<=0 && iAmt >= 512 && iAmt <= 64*1024 && !(iAmt & (iAmt - 1)) ){
     // new compress db need set orignal db's pagesize
     rc = setCompressPgsize(db, iAmt);
     if( rc!=SQLITE_OK ){
+      sqlite3_log(rc, "Save page size(%d) wrong, ofst:%lld, flags:%d", iAmt, iOfst, pCompress->openFlags);
       return SQLITE_IOERR_WRITE;
     }
-    pCompress->page_size = iAmt;
+    pCompress->pageSize = iAmt;
   }
-  int pgsize = pCompress->page_size;
+  int pgsize = pCompress->pageSize;
   int pgno = iOfst / pgsize + 1;
   if( iAmt!=pgsize || iOfst % pgsize!=0 ){
+    sqlite3_log(SQLITE_IOERR_WRITE, "Mismatch info, iAmt(%d), pgsz(%d), offset:%ld", iAmt, pgsize, iOfst);
     return SQLITE_IOERR_WRITE;
   }
 
-  int max_compress_size = compressLen(iAmt, pCompress->compression);
-  if( max_compress_size<=0 ){
+  int maxSize = compressLen(iAmt, pCompress->compression);
+  if( maxSize<=0 ){
+    sqlite3_log(SQLITE_IOERR_WRITE, "Get compress size(%d) wrong, compression(%d)", maxSize, pCompress->compression);
     return SQLITE_IOERR_WRITE;
   }
-  u8 *compressed_data = sqlite3_malloc(max_compress_size);
-  if( compressed_data==NULL ){
+  u8 *tmpData = sqlite3_malloc(maxSize);
+  if( tmpData==NULL ){
+    sqlite3_log(SQLITE_NOMEM, "Malloc size(%d) wrong", maxSize);
     return SQLITE_NOMEM;
   }
-  int compress_data_len = 0;
-  if( compressBuf(compressed_data, max_compress_size, &compress_data_len, pBuf, iAmt, pCompress->compression) ){
-    sqlite3_free(compressed_data);
+  int len = 0;
+  if( compressBuf(tmpData, maxSize, &len, pBuf, iAmt, pCompress->compression) ){
+    sqlite3_free(tmpData);
+    sqlite3_log(SQLITE_IOERR_WRITE, "Compress buf wrong, pgno(%d), amt(%d), ofst(%lld)", pgno, iAmt, iOfst);
     return SQLITE_IOERR_WRITE;
   }
   if( pCompress->bBegin!=1 ){
-    if( sqlite3_exec(db, "BEGIN;", NULL, NULL, NULL)!=SQLITE_OK ){
-      sqlite3_free(compressed_data);
+    if( (rc = sqlite3_exec(db, "BEGIN;", NULL, NULL, NULL))!=SQLITE_OK ){
+      sqlite3_free(tmpData);
+      sqlite3_log(rc, "Begin transaction to insert compressed page wrong, pgno(%d), ofst(%lld)", pgno, iOfst);
       return SQLITE_IOERR_WRITE;
     }
     pCompress->bBegin = 1;
   }
   sqlite3_stmt *stmt = NULL;
   const char *sql = "INSERT OR REPLACE INTO vfs_pages(data, pageno) VALUES (?,?);";
-  if( sqlite3_prepare_v2(db, sql, -1, &stmt, NULL)==SQLITE_OK ){
-    sqlite3_bind_blob(stmt, 1, compressed_data, compress_data_len, SQLITE_STATIC);
-    sqlite3_bind_int(stmt, 2, pgno);
-    if( sqlite3_step(stmt)!=SQLITE_DONE ){
-      sqlite3_free(compressed_data);
-      sqlite3_finalize(stmt);
-      return SQLITE_IOERR_WRITE;
+  rc = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
+  if( rc!=SQLITE_OK ){
+    sqlite3_free(tmpData);
+    sqlite3_log(rc, "Prepare stat to insert page wrong, pgno(%d), ofst(%lld)", pgno, iOfst);
+    return SQLITE_IOERR_WRITE;
+  }
+  sqlite3_bind_blob(stmt, 1, tmpData, len, SQLITE_STATIC);
+  sqlite3_bind_int(stmt, 2, pgno);
+  rc = sqlite3_step(stmt);
+  sqlite3_finalize(stmt);
+  sqlite3_free(tmpData);
+  if( rc!=SQLITE_DONE ){
+    if( rc!=SQLITE_BUSY ){
+      sqlite3_log(rc, "Compress db insert page wrong, pgno(%d), ofst(%lld)", pgno, iOfst);
     }
-    sqlite3_finalize(stmt);
+    return SQLITE_IOERR_WRITE;
   }
-  sqlite3_free(compressed_data);
   return SQLITE_OK;
 }
 
@@ -731,71 +775,83 @@ static int compressRead(sqlite3_file *pFile, void *pBuf, int iAmt, sqlite_int64
   }
   (void)memset_s(pBuf, iAmt, 0, iAmt);
   sqlite3 *db = pCompress->pDb;
-  int rc = getCompressPgsize(db, &pCompress->page_size);
-  if( rc!=SQLITE_OK || pCompress->page_size==0 ){
+  int rc = getCompressPgsize(db, &pCompress->pageSize);
+  if( rc!=SQLITE_OK || pCompress->pageSize==0 ){
+    sqlite3_log(SQLITE_WARNING_DUMP, "Missing pgsz(%d), read ofst(%lld), amt(%d), flags(%d)", pCompress->pageSize,
+      iOfst, iAmt, pCompress->openFlags);
     return SQLITE_IOERR_SHORT_READ;
   }
-  int pgsize = pCompress->page_size;
+  int pgsize = pCompress->pageSize;
   int pgno = iOfst / pgsize + 1;
   int dataidx = iOfst % pgsize;
   sqlite3_stmt *stmt = NULL;
   const char *sql = "SELECT data, length(data) FROM vfs_pages WHERE pageno=?;";
   const void *data = NULL;
-  int data_len = 0;
+  int dataLen = 0;
   rc = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
   if( rc!=SQLITE_OK ){
+    sqlite3_log(rc, "Prepare to get compressed page(%d) wrong, ofst(%lld)", pgno, iOfst);
     return SQLITE_CORRUPT;
   }
-  u8 *decompressed_data = NULL;
+  u8 *decompressedData = NULL;
   if( pgsize!=iAmt ){
-    decompressed_data = sqlite3_malloc(pgsize);
-    if( decompressed_data==NULL ){
+    decompressedData = sqlite3_malloc(pgsize);
+    if( decompressedData==NULL ){
       sqlite3_finalize(stmt);
+      sqlite3_log(SQLITE_NOMEM, "Malloc for decompress size(%d) wrong, amt(%d), ofst(%lld)", pgsize, iAmt, iOfst);
       return SQLITE_NOMEM;
     }
   }else{
-    decompressed_data = (u8*)pBuf;
+    decompressedData = (u8*)pBuf;
   }
 
-  int decompress_data_len = 0;
+  int decompressLen = 0;
   sqlite3_bind_int(stmt, 1, pgno);
   rc = sqlite3_step(stmt);
   if( rc==SQLITE_ROW ){
     data = sqlite3_column_blob(stmt, 0);
     if( data==NULL ){
       rc = SQLITE_IOERR_SHORT_READ;
-      goto failed;
+      sqlite3_log(rc, "Get compress page(%d) wrong, empty data, amt(%d), ofst(%lld)", pgno, iAmt, iOfst);
+      goto END_OUT;
     }
-    data_len = sqlite3_column_int(stmt, 1);
-    if( data_len==0 ){
+    dataLen = sqlite3_column_int(stmt, 1);
+    if( dataLen==0 ){
       rc = SQLITE_IOERR_SHORT_READ;
-      goto failed;
+      sqlite3_log(rc, "Get compress page(%d) wrong, short data, amt(%d), ofst(%lld)", pgno, iAmt, iOfst);
+      goto END_OUT;
     }
-    if( decompressBuf(decompressed_data, pgsize, &decompress_data_len, data, data_len,
-      pCompress->compression)!=SQLITE_OK ){
+    if( decompressBuf(decompressedData, pgsize, &decompressLen, data, dataLen, pCompress->compression)!=SQLITE_OK ){
       rc = SQLITE_IOERR_SHORT_READ;
-      goto failed;
+      sqlite3_log(rc, "Decompress page(%d) wrong, compression(%d), len(%d), amt(%d), ofst(%lld)", pgno,
+        (int)pCompress->compression, dataLen, iAmt, iOfst);
+      goto END_OUT;
     }
-    if( decompress_data_len!=pgsize ){
+    if( decompressLen!=pgsize ){
       rc = SQLITE_IOERR_SHORT_READ;
-      goto failed;
+      sqlite3_log(rc, "Decompress page(%d) wrong, size(%d), pgsz(%d), amt(%d), ofst(%lld)", pgno,
+        decompressLen, pgsize, iAmt, iOfst);
+      goto END_OUT;
     }
     if( pgsize!=iAmt ){
-      rc = memcpy_s(pBuf, iAmt, decompressed_data+dataidx, iAmt);
+      rc = memcpy_s(pBuf, iAmt, decompressedData+dataidx, iAmt);
       if( rc!=SQLITE_OK ){
         rc = SQLITE_IOERR_SHORT_READ;
-        goto failed;
+        sqlite3_log(rc, "Copy decompress page(%d) wrong, size(%d), pgsz(%d), amt(%d), ofst(%lld)", pgno,
+          decompressLen, pgsize, iAmt, iOfst);
+        goto END_OUT;
       }
     }
     rc = SQLITE_OK;
   }else if( rc==SQLITE_DONE ){
-    rc = SQLITE_IOERR_SHORT_READ;
+    rc = SQLITE_BUSY;
+    sqlite3_log(SQLITE_WARNING_DUMP, "Missing page(%d) while try read, may busy now", pgno);
   }
 
- failed:
+END_OUT:
   sqlite3_finalize(stmt);
   if( pgsize!=iAmt ){
-    sqlite3_free(decompressed_data);
+    sqlite3_free(decompressedData);
   }
 
   return rc;
@@ -808,6 +864,7 @@ static int compressClose(sqlite3_file *pFile){
   assert( pFile );
   CompressFile *pCompress = (CompressFile *)pFile;
   sqlite3 *db = pCompress->pDb;
+  sqlite3_file *pSubFile = ORIGFILE(pFile);
   int rc = compressSync(pFile, 0);
   if( rc!=SQLITE_OK ){
     return rc;
@@ -821,9 +878,13 @@ static int compressClose(sqlite3_file *pFile){
       pCompress->pDb = NULL;
     }
   }
+  if( pCompress->pLockFd ){
+    pSubFile->pMethods->xClose(pCompress->pLockFd);
+    sqlite3_free(pCompress->pLockFd);
+    pCompress->pLockFd = NULL;
+  }
   if( pCompress->bSubDbOpen ){
-    pFile = ORIGFILE(pFile);
-    rc = pFile->pMethods->xClose(pFile);
+    rc = pSubFile->pMethods->xClose(pSubFile);
   }
   return rc;
 }
@@ -888,6 +949,69 @@ static int compressUnfetch(sqlite3_file *pFile, sqlite3_int64 iOfst, void *pPage
   return SQLITE_OK;
 }
 
+static int compressOpenLockFile(sqlite3_vfs *pVfs, const char *zName, int flags, sqlite3_file **pFile){
+  const char *walPath = sqlite3_filename_wal(zName);
+  const char *lockPath = walPath + strlen(walPath) + 1;  // For compress vfs, lock path place at this position
+  int isLockExist = 0;
+  int rc = ORIGVFS(pVfs)->xAccess(ORIGVFS(pVfs), lockPath, SQLITE_ACCESS_READWRITE, &isLockExist);
+  if( rc!=SQLITE_OK ){
+    sqlite3_log(rc, "Access lock file failed, path:%s", lockPath);
+    return rc;
+  }
+  if( isLockExist==0 && ((flags&SQLITE_OPEN_CREATE)==0) ){
+    sqlite3_log(SQLITE_WARNING_NOTCOMPRESSDB, "Check lock wrong, compress db should have lock file");
+    return SQLITE_WARNING_NOTCOMPRESSDB;
+  }
+  if( pVfs->szOsFile<=(int)sizeof(CompressFile) ){
+    sqlite3_log(SQLITE_CANTOPEN, "Unexpected file handle size(%d), vfs:%s", pVfs->szOsFile, pVfs->zName);
+    return SQLITE_CANTOPEN;
+  }
+  sqlite3_file *pLockFd = sqlite3_malloc(pVfs->szOsFile - sizeof(CompressFile));
+  if( pLockFd==NULL ){
+    rc = SQLITE_NOMEM;
+    sqlite3_log(rc, "Malloc file handle for lock wrong, size(%d)", (int)(pVfs->szOsFile - sizeof(CompressFile)));
+    return rc;
+  }
+  memset(pLockFd, 0, pVfs->szOsFile - sizeof(CompressFile));
+  rc = ORIGVFS(pVfs)->xOpen(ORIGVFS(pVfs), lockPath, pLockFd, flags, NULL);
+  if( rc!=SQLITE_OK ){
+    sqlite3_log(rc, "Compress vfs lock file open wrong, path:%s, flag(%d)", lockPath, flags);
+    sqlite3_free(pLockFd);
+    return rc;
+  }
+  *pFile = pLockFd;
+  return rc;
+}
+
+static int compressDbInitCompression(CompressFile *pCompress, sqlite3 *db, u32 compression){
+  const char *pragmaStr = "PRAGMA checksum_persist_enable=ON;PRAGMA page_size=4096;PRAGMA auto_vacuum=INCREMENTAL;";
+  int rc = sqlite3_exec(db, pragmaStr, NULL, NULL, NULL);
+  if( rc!=SQLITE_OK ){
+    sqlite3_log(rc, "Config compress db wrong, name");
+    return SQLITE_CANTOPEN;
+  }
+  const char *initCompressionStr = "CREATE TABLE IF NOT EXISTS vfs_compression(compression INTEGER, pagesize INTEGER);";
+  rc = sqlite3_exec(db, initCompressionStr, NULL, NULL, NULL);
+  if( rc!=SQLITE_OK ){
+    sqlite3_log(rc, "Configure compress db wrong, create vfs_compression failed");
+    return SQLITE_CANTOPEN;
+  }
+  char compressionSql[COMPRESSION_SQL_MAX_LENGTH] = {0};
+  if( sprintf_s(compressionSql, COMPRESSION_SQL_MAX_LENGTH,
+    "INSERT OR IGNORE INTO vfs_compression(compression, pagesize) VALUES (%u, 0);", compression)<=0 ){
+    sqlite3_log(rc, "Concatenate config stat wrong, compression(%u)", compression);
+    return SQLITE_CANTOPEN;
+  }
+  rc = sqlite3_exec(db, compressionSql, NULL, NULL, NULL);
+  if( rc!=SQLITE_OK ){
+    sqlite3_log(rc, "Config compress db wrong, insert compression(%u) failed", compression);
+    return SQLITE_CANTOPEN;
+  }
+  pCompress->compression = compression;
+  pCompress->pageSize = 0;
+  return SQLITE_OK;
+}
+
 /*
 ** Open a compress file.If this file is not a journal or wal file,
 ** it will open a OutterDB and create vfs_pages and vfs_compression table
@@ -902,87 +1026,103 @@ static int compressOpen(
 ){
   sqlite3_file *pSubFile = ORIGFILE(pFile);
   CompressFile *pCompress = (CompressFile *)pFile;
+  pCompress->openFlags = flags;
   int rc = SQLITE_OK;
   if( !(flags & (SQLITE_OPEN_MAIN_DB|SQLITE_OPEN_TEMP_DB)) ){
     return ORIGVFS(pVfs)->xOpen(ORIGVFS(pVfs), zName, pFile, flags, pOutFlags);
   }
   rc = ORIGVFS(pVfs)->xOpen(ORIGVFS(pVfs), zName, pSubFile, flags, pOutFlags);
   if( rc!=SQLITE_OK ){
+    sqlite3_log(rc, "Compress file open wrong, path:%s, flags:%d", zName, flags);
     return rc;
   }
   pCompress->bSubDbOpen = 1;
   sqlite3_int64 fileSize = 0;
+  u8 isExist = 0;
+  sqlite3 *db = NULL;
   rc = pSubFile->pMethods->xFileSize(pSubFile, &fileSize);
   if( rc!=SQLITE_OK ){
+    sqlite3_log(rc, "Calculate compress file size wrong, path:%s", zName);
     rc = SQLITE_CANTOPEN;
-    goto open_end;
+    goto END_OUT;
   }
 
+  rc = compressOpenLockFile(pVfs, zName, flags, &pCompress->pLockFd);
+  if( rc!=SQLITE_OK ){
+    sqlite3_log(rc, "Compress vfs lock file open wrong, path:%s, flag(%d)", zName, flags);
+    goto END_OUT;
+  }
   pFile->pMethods = &compress_io_methods;
-  rc = sqlite3_open_v2(zName, &pCompress->pDb, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_FULLMUTEX, ORIGVFS(pVfs)->zName);
+  rc = sqlite3_open_v2(zName, &db, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_FULLMUTEX, CKSM_VFS_NAME);
   if( rc!=SQLITE_OK ){
+    sqlite3_log(rc, "Open compress db wrong, name:%s", zName);
     rc = SQLITE_CANTOPEN;
-    goto open_end;
+    goto END_OUT;
   }
-  pCompress->bOutterDbOpen = 1;
-  sqlite3 *db = pCompress->pDb;
-  const char *pre_pragma = "PRAGMA page_size=4096;"\
-    "PRAGMA auto_vacuum=INCREMENTAL;PRAGMA journal_mode=OFF;";
   sqlite3_busy_timeout(db, 2000);  // Set time out:2s
-  rc = sqlite3_exec(db, pre_pragma, NULL, NULL, NULL);
+  rc = sqlite3_exec(db, "PRAGMA journal_mode=OFF;", NULL, NULL, NULL);
   if( rc!=SQLITE_OK ){
-    rc = SQLITE_CANTOPEN;
-    goto open_end;
+    sqlite3_log(rc, "Config compress db journal mode wrong, name:%s", zName);
+    goto END_OUT;
+  }
+  pCompress->bOutterDbOpen = 1;
+  rc = tableExists(db, "vfs_compression", &isExist);
+  if( rc!=SQLITE_OK ) {
+    return rc;
   }
-  if( tableExists(db, "vfs_compression") ){
+  if( isExist ){
     getCompression(db, pCompress);
     if( pCompress->compression!=COMPRESSION_BROTLI && pCompress->compression!=COMPRESSION_ZSTD ){
       rc = SQLITE_CANTOPEN;
-      goto open_end;
+      sqlite3_log(rc, "Unrecognized compression(%d), name:%s", pCompress->compression, zName);
+      goto END_OUT;
     }
-    if( loadCompressAlgorithmExtension(pCompress->compression)==SQLITE_ERROR ){
+    if( loadCompressAlgorithmExtension(pCompress->compression)!=SQLITE_OK ){
       rc = SQLITE_CANTOPEN;
-      goto open_end;
+      goto END_OUT;
     }
   }else if( flags&SQLITE_OPEN_MAIN_DB && fileSize!=0 ){
     rc = SQLITE_WARNING_NOTCOMPRESSDB;
     sqlite3_log(rc, "open compress database go wrong, it should be a compressed db");
-    goto open_end;
+    goto END_OUT;
   }else{
     if( loadCompressAlgorithmExtension(COMPRESSION_UNDEFINED)==SQLITE_ERROR ){
       rc = SQLITE_CANTOPEN;
-      goto open_end;
+      goto END_OUT;
     }
-    const char *init_compression_sql = "CREATE TABLE vfs_compression (compression INTEGER, pagesize INTEGER);";
-    rc = sqlite3_exec(db, init_compression_sql, NULL, NULL, NULL);
+    rc = compressDbInitCompression(pCompress, db, g_compress_algo_load);
     if( rc!=SQLITE_OK ){
-      rc = SQLITE_CANTOPEN;
-      goto open_end;
+      sqlite3_log(rc, "Init compression info wrong, name:%s", zName);
+      goto END_OUT;
     }
-    char set_compression_sql[COMPRESSION_SQL_MAX_LENGTH] = {0};
-    if( sprintf_s(set_compression_sql, COMPRESSION_SQL_MAX_LENGTH,
-      "INSERT INTO vfs_compression(compression, pagesize) VALUES (%u, 0);", g_compress_algo_load)<=0 ){
-      rc = SQLITE_CANTOPEN;
-      goto open_end;
-    }
-    rc = sqlite3_exec(db, set_compression_sql, NULL, NULL, NULL);
-    if( rc!=SQLITE_OK ){
-      rc = SQLITE_CANTOPEN;
-      goto open_end;
-    }
-    pCompress->compression = g_compress_algo_load;
-    pCompress->page_size = 0;
   }
-  if( tableExists(db, "vfs_pages") ){
-    goto open_end;
+  rc = tableExists(db, "vfs_pages", &isExist);
+  if( rc!=SQLITE_OK ){
+    goto END_OUT;
   }
-  const char *create_sql = "CREATE TABLE vfs_pages (pageno INTEGER PRIMARY KEY, data BLOB NOT NULL);";
-  rc = sqlite3_exec(db, create_sql, NULL, NULL, NULL);
+  if( isExist ){
+    goto END_OUT;
+  }
+  const char *pageDdlStr = "CREATE TABLE IF NOT EXISTS vfs_pages (pageno INTEGER PRIMARY KEY, data BLOB NOT NULL);";
+  rc = sqlite3_exec(db, pageDdlStr, NULL, NULL, NULL);
   if( rc!=SQLITE_OK ){
+    sqlite3_log(rc, "Config compress db wrong, name:%s, create page table failed", zName);
     rc = SQLITE_CANTOPEN;
   }
 
- open_end:
+END_OUT:
+  if( rc==SQLITE_OK ){
+    pCompress->pDb = db;
+  }else{
+    if( db!=NULL ){
+      sqlite3_close_v2(db);
+    }
+    if( pCompress->pLockFd ){
+      pSubFile->pMethods->xClose(pCompress->pLockFd);
+      sqlite3_free(pCompress->pLockFd);
+      pCompress->pLockFd = NULL;
+    }
+  }
   return rc;
 }
 
diff --git a/src/sqlite3.c b/src/sqlite3.c
index 74366de..367eef9 100644
--- a/src/sqlite3.c
+++ b/src/sqlite3.c
@@ -5363,7 +5363,7 @@ SQLITE_API int sqlite3_set_droptable_handle(sqlite3*, void (*xFunc)(sqlite3*,con
 #endif /* SQLITE_ENABLE_DROPTABLE_CALLBACK */
 
 #ifdef SQLITE_ENABLE_BINLOG
-SQLITE_API int sqlite3_is_support_binlog(void);
+SQLITE_API int sqlite3_is_support_binlog(const char *notUsed);
 
 SQLITE_API int sqlite3_replay_binlog(sqlite3 *srcDb, sqlite3 *destDb);
 
@@ -15050,6 +15050,14 @@ typedef INT16_TYPE LogEst;
 #define LARGEST_UINT64 (0xffffffff|(((u64)0xffffffff)<<32))
 #define SMALLEST_INT64 (((i64)-1) - LARGEST_INT64)
 
+/*
+** Macro SMXV(n) return the maximum value that can be held in variable n,
+** assuming n is a signed integer type.  UMXV(n) is similar for unsigned
+** integer types.
+*/
+#define SMXV(n) ((((i64)1)<<(sizeof(n)*8-1))-1)
+#define UMXV(n) ((((i64)1)<<(sizeof(n)*8))-1)
+
 /*
 ** Round up a number to the next larger multiple of 8.  This is used
 ** to force 8-byte alignment on 64-bit architectures.
@@ -19063,7 +19071,7 @@ struct AggInfo {
                           ** from source tables rather than from accumulators */
   u8 useSortingIdx;       /* In direct mode, reference the sorting index rather
                           ** than the source table */
-  u16 nSortingColumn;     /* Number of columns in the sorting index */
+  u32 nSortingColumn;     /* Number of columns in the sorting index */
   int sortingIdx;         /* Cursor number of the sorting index */
   int sortingIdxPTab;     /* Cursor number of pseudo-table */
   int iFirstReg;          /* First register in range for aCol[] and aFunc[] */
@@ -19072,8 +19080,8 @@ struct AggInfo {
     Table *pTab;             /* Source table */
     Expr *pCExpr;            /* The original expression */
     int iTable;              /* Cursor number of the source table */
-    i16 iColumn;             /* Column number within the source table */
-    i16 iSorterColumn;       /* Column number in the sorting index */
+    int iColumn;             /* Column number within the source table */
+    int iSorterColumn;       /* Column number in the sorting index */
   } *aCol;
   int nColumn;            /* Number of used entries in aCol[] */
   int nAccumulator;       /* Number of columns that show through to the output.
@@ -38807,8 +38815,8 @@ static void enableDbFileDelMonitor(int32_t fd)
     }
     flags |= HMFS_MONITOR_FL;
     ret = ioctl(fd, HMFS_IOCTL_HW_SET_FLAGS, &flags);
-    if (ret < 0) {
-        sqlite3_log(SQLITE_WARNING, "Fd %d enable del monitor go wrong, errno = %d", fd, errno);
+    if (ret < 0 && errno != EACCES) {
+        sqlite3_log(SQLITE_WARNING, "Flags %u fd %d enable del monitor go wrong, errno = %d", flags, fd, errno);
     }
 }
 
@@ -42228,6 +42236,24 @@ static int openDirectory(const char *zFilename, int *pFd){
   return unixLogError(SQLITE_CANTOPEN_BKPT, "openDirectory", zDirname);
 }
 
+#ifdef LOG_DUMP
+static int unixCurrentTimeInt64(sqlite3_vfs *NotUsed, sqlite3_int64 *piNow);
+static int dirSyncTimeCostAlert(int fd, int fullSync, int dataOnly)
+{
+  sqlite3_int64 startTimeMs = 0;
+  sqlite3_int64 endTimeMs = 0;
+  // unixCurrentTimeInt64 always return OK
+  (void)unixCurrentTimeInt64(0, &startTimeMs);
+  int rc = full_fsync(fd, 0, 0);
+  (void)unixCurrentTimeInt64(0, &endTimeMs);
+  // 1500 ms
+  if (unlikely(endTimeMs >= (startTimeMs + 1500))) {
+    sqlite3_log(SQLITE_WARNING_DUMP, "[SQLite]Dir sync takes %lld ms", endTimeMs - startTimeMs);
+  }
+  return rc;
+}
+#endif
+
 /*
 ** Make sure all writes to a particular file are committed to disk.
 **
@@ -42279,7 +42305,11 @@ static int unixSync(sqlite3_file *id, int flags){
             HAVE_FULLFSYNC, isFullsync));
     rc = osOpenDirectory(pFile->zPath, &dirfd);
     if( rc==SQLITE_OK ){
+#ifndef LOG_DUMP
       full_fsync(dirfd, 0, 0);
+#else
+      dirSyncTimeCostAlert(dirfd, 0, 0);
+#endif
       robust_close(pFile, dirfd, __LINE__);
     }else{
       assert( rc==SQLITE_CANTOPEN );
@@ -57984,6 +58014,8 @@ static void MetaDwrCheckVacuum(BtShared *pBt);
 static int MetaDwrRecoverAndBeginTran(Btree *pBt, int wrflag, int *pSchemaVersion);
 static int MetaDwrOpenAndCheck(Btree *pBt);
 static void MetaDwrDisable(Btree *pBt);
+static void MetaDwrDumpInfo(Pager *pPager);
+static void MetaDwrCommitUpdate(Pager *pPager);
 #define META_HEADER_CHANGED 1
 #define META_SCHEMA_CHANGED 2
 #define META_IN_RECOVERY 1
@@ -58261,6 +58293,9 @@ struct Pager {
   void *metaMapPage;
   int (*xGetMethod)(Pager*,Pgno,DbPage**,int); /* Routine to fetch a patch */
 #endif
+#ifdef SQLITE_ENABLE_PAGE_COMPRESS
+  char *zLock;                /* Point to the lock filename, use to replace main db to lock */
+#endif
 };
 
 /*
@@ -59762,11 +59797,12 @@ static int pager_end_transaction(Pager *pPager, int hasSuper, int bCommit){
     sqlite3PcacheTruncate(pPager->pPCache, pPager->dbSize);
   }
 #ifdef SQLITE_META_DWR
-  if (bCommit && pPager->metaChanged != 0) {
-    sqlite3BeginBenignMalloc();
-    (void)MetaDwrWriteHeader(pPager, pPager->metaHdr);
-    sqlite3EndBenignMalloc();
-    pPager->metaChanged = 0;
+  if (bCommit) {
+    MetaDwrCommitUpdate(pPager);
+    if (pPager->metaChanged != 0) {
+      (void)MetaDwrWriteHeader(pPager, pPager->metaHdr);
+      pPager->metaChanged = 0;
+    }
   }
 #endif
   if( pagerUseWal(pPager) ){
@@ -62555,7 +62591,8 @@ SQLITE_PRIVATE int sqlite3PagerOpen(
   ** specific formatting and order of the various filenames, so if the format
   ** changes here, be sure to change it there as well.
   **
-  ** Addition, in case of enable page compression, journal&WAL filename will add a file extension:"compress"
+  ** Addition, in case of enable page compression, journal&WAL filename will add a file extension:"compress",
+  ** lock file need an other setting
   ** So the final layout in memory is as follows:
   **
   **     Pager object                    (sizeof(Pager) bytes)
@@ -62569,13 +62606,16 @@ SQLITE_PRIVATE int sqlite3PagerOpen(
   **     URI query parameters            (nUriByte bytes)
   **     Journal filename                (nPathname+16+1 bytes)
   **     WAL filename                    (nPathname+12+1 bytes)
+  **     Lock filename                   (nPathname+13+1 bytes)
   **     \0\0\0 terminator               (3 bytes)
   **
   */
   int fileExtSz = 0;
+  int lockExtSz = 0;
 #ifdef SQLITE_ENABLE_PAGE_COMPRESS
   if( sqlite3_stricmp(pVfs->zName, "compressvfs")==0 ){
     fileExtSz = 8;  /* 8 means the size of suffix:"compress" */
+    lockExtSz = 13;  /* 13 means the size of suffix:"-lockcompress" */
   }
 #endif
   assert( SQLITE_PTRSIZE==sizeof(Pager*) );
@@ -62591,6 +62631,9 @@ SQLITE_PRIVATE int sqlite3PagerOpen(
     nPathname + 8 + fileExtSz + 1 +      /* Journal filename */
 #ifndef SQLITE_OMIT_WAL
     nPathname + 4 + fileExtSz + 1 +      /* WAL filename */
+#endif
+#ifdef SQLITE_ENABLE_PAGE_COMPRESS
+    nPathname + lockExtSz + 1 +          /* Lock filename */
 #endif
     3                                    /* Terminator */
   );
@@ -62659,6 +62702,19 @@ SQLITE_PRIVATE int sqlite3PagerOpen(
     pPager->zWal = 0;
   }
 #endif
+
+#ifdef SQLITE_ENABLE_PAGE_COMPRESS
+  if( nPathname>0 ){
+    pPager->zLock = (char*)pPtr;
+    memcpy(pPtr, zPathname, nPathname);   pPtr += nPathname;
+    if( lockExtSz>0 ){  /* 13 means the size of string:"-lockcompress" */
+      memcpy(pPtr, "-lockcompress", 13);  pPtr += lockExtSz;
+    }
+                                          pPtr += 1;  /* Skip zero suffix */
+  }else{
+    pPager->zLock = 0;
+  }
+#endif
   (void)pPtr;  /* Suppress warning about unused pPtr value */
 
   if( nPathname ) sqlite3DbFree(0, zPathname);
@@ -73800,7 +73856,13 @@ static void zeroPage(MemPage *pPage, int flags){
   data[hdr+7] = 0;
   put2byte(&data[hdr+5], pBt->usableSize);
   pPage->nFree = (u16)(pBt->usableSize - first);
-  decodeFlags(pPage, flags);
+  /*
+  ** pPage might not be a btree page, it might be ovf/ptrmap/free page
+  ** and decodeFlags() return SQLITE_CORRUPT, but no harm is done by this
+  */
+  if( decodeFlags(pPage, flags)==SQLITE_CORRUPT ){
+    sqlite3_log(SQLITE_WARNING_DUMP, "warn: zero page, might be ovf/ptrmap/free page:%d", pPage->pgno);
+  }
   pPage->cellOffset = first;
   pPage->aDataEnd = &data[pBt->pageSize];
   pPage->aCellIdx = &data[first];
@@ -74009,7 +74071,9 @@ static void pageReinit(DbPage *pData){
       ** But no harm is done by this.  And it is very important that
       ** btreeInitPage() be called on every btree page so we make
       ** the call for every page that comes in for re-initializing. */
-      btreeInitPage(pPage);
+      if( btreeInitPage(pPage)==SQLITE_CORRUPT ){
+        sqlite3_log(SQLITE_WARNING_DUMP, "warn: page reinit, might be ovf/ptrmap/free page:%d", pPage->pgno);
+      }
     }
   }
 }
@@ -74925,6 +74989,11 @@ static int lockBtree(BtShared *pBt){
     }
     if( nPage>nPageFile ){
       if( sqlite3WritableSchema(pBt->db)==0 ){
+        sqlite3_log(SQLITE_WARNING_DUMP, "sqlite3WritableSchema nPage %d nPageFile %d", nPage, nPageFile);
+#ifdef SQLITE_META_DWR
+        DumpLocksByPager(pBt->pPager);
+        MetaDwrDumpInfo(pBt->pPager);
+#endif
         rc = SQLITE_CORRUPT_BKPT;
         goto page1_init_failed;
       }else{
@@ -92384,8 +92453,9 @@ SQLITE_API int sqlite3_set_droptable_handle(sqlite3 *db, void (*xFunc)(sqlite3*,
 #endif /* SQLITE_ENABLE_DROPTABLE_CALLBACK */
 
 #ifdef SQLITE_ENABLE_BINLOG
-SQLITE_API int sqlite3_is_support_binlog(void)
+SQLITE_API int sqlite3_is_support_binlog(const char *notUsed)
 {
+  (void)notUsed;
   return SQLITE_ERROR;
 }
 
@@ -116893,7 +116963,9 @@ static void findOrCreateAggInfoColumn(
 ){
   struct AggInfo_col *pCol;
   int k;
+  int mxTerm = pParse->db->aLimit[SQLITE_LIMIT_COLUMN];
 
+  assert( mxTerm <= SMXV(i16) );
   assert( pAggInfo->iFirstReg==0 );
   pCol = pAggInfo->aCol;
   for(k=0; k<pAggInfo->nColumn; k++, pCol++){
@@ -116911,6 +116983,10 @@ static void findOrCreateAggInfoColumn(
     assert( pParse->db->mallocFailed );
     return;
   }
+  if( k>mxTerm ){
+    sqlite3ErrorMsg(pParse, "more than %d aggregate terms", mxTerm);
+    k = mxTerm;
+  }
   pCol = &pAggInfo->aCol[k];
   assert( ExprUseYTab(pExpr) );
   pCol->pTab = pExpr->y.pTab;
@@ -116944,6 +117020,7 @@ fix_up_expr:
   if( pExpr->op==TK_COLUMN ){
     pExpr->op = TK_AGG_COLUMN;
   }
+  assert( k <= SMXV(pExpr->iAgg) );
   pExpr->iAgg = (i16)k;
 }
 
@@ -117027,13 +117104,19 @@ static int analyzeAggregate(Walker *pWalker, Expr *pExpr){
         ** function that is already in the pAggInfo structure
         */
         struct AggInfo_func *pItem = pAggInfo->aFunc;
+        int mxTerm = pParse->db->aLimit[SQLITE_LIMIT_COLUMN];
+        assert( mxTerm <= SMXV(i16) );
         for(i=0; i<pAggInfo->nFunc; i++, pItem++){
           if( pItem->pFExpr==pExpr ) break;
           if( sqlite3ExprCompare(0, pItem->pFExpr, pExpr, -1)==0 ){
             break;
           }
         }
-        if( i>=pAggInfo->nFunc ){
+        if( i>mxTerm ){
+          sqlite3ErrorMsg(pParse, "more than %d aggregate terms", mxTerm);
+          i = mxTerm;
+          assert( i<pAggInfo->nFunc );
+        }else if( i>=pAggInfo->nFunc ){
           /* pExpr is original.  Make a new entry in pAggInfo->aFunc[]
           */
           u8 enc = ENC(pParse->db);
@@ -117085,6 +117168,7 @@ static int analyzeAggregate(Walker *pWalker, Expr *pExpr){
         */
         assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );
         ExprSetVVAProperty(pExpr, EP_NoReduce);
+        assert( i <= SMXV(pExpr->iAgg) );
         pExpr->iAgg = (i16)i;
         pExpr->pAggInfo = pAggInfo;
         return WRC_Prune;
@@ -121797,8 +121881,8 @@ static void attachFunc(
   if( rc==SQLITE_OK ){
     extern int sqlite3CodecAttach(sqlite3*, int, const void*, int);
     extern void sqlite3CodecGetKey(sqlite3*, int, void**, int*);
-    int nKey;
-    char *zKey;
+    int nKey = 0;
+    char *zKey = NULL;
     int t = sqlite3_value_type(argv[2]);
     switch( t ){
       case SQLITE_INTEGER:
@@ -121815,14 +121899,7 @@ static void attachFunc(
         break;
 
       case SQLITE_NULL:
-        /* No key specified.  Use the key from URI filename, or if none,
-        ** use the key from the main database. */
-        if( sqlite3CodecQueryParameters(db, zName, zPath)==0 ){
-          sqlite3CodecGetKey(db, 0, (void**)&zKey, &nKey);
-          if( nKey || sqlite3BtreeGetRequestedReserve(db->aDb[0].pBt)>0 ){
-            rc = sqlite3CodecAttach(db, db->nDb-1, zKey, nKey);
-          }
-        }
+        /* No key specified. just use null key. */
         break;
     }
   }
@@ -184194,10 +184271,12 @@ opendb_out:
     db->eOpenState = SQLITE_STATE_SICK;
   }
 #ifdef SQLITE_ENABLE_DROPTABLE_CALLBACK
-  db->isDropTable = 0;
-  db->mDropTableName = NULL;
-  db->mDropSchemaName = NULL;
-  db->xDropTableHandle = NULL;
+  if( db!=0 ){
+    db->isDropTable = 0;
+    db->mDropTableName = NULL;
+    db->mDropSchemaName = NULL;
+    db->xDropTableHandle = NULL;
+  }
 #endif /* SQLITE_ENABLE_DROPTABLE_CALLBACK */
 #ifdef SQLITE_ENABLE_BINLOG
   sqlite3BinlogReset(db);
@@ -204642,6 +204721,39 @@ static int fts3ExprTermOffsetInit(Fts3Expr *pExpr, int iPhrase, void *ctx){
   return rc;
 }
 
+/*
+** Expression node pExpr is an MSR phrase. This function restarts pExpr
+** so that it is a regular phrase query, not an MSR. SQLITE_OK is returned
+** if successful, or an SQLite error code otherwise.
+*/
+int sqlite3Fts3MsrCancel(Fts3Cursor *pCsr, Fts3Expr *pExpr){
+  int rc = SQLITE_OK;
+  if( pExpr->bEof==0 ){
+    i64 iDocid = pExpr->iDocid;
+    fts3EvalRestart(pCsr, pExpr, &rc);
+    while( rc==SQLITE_OK && pExpr->iDocid!=iDocid ){
+      fts3EvalNextRow(pCsr, pExpr, &rc);
+      if( pExpr->bEof ) rc = FTS_CORRUPT_VTAB;
+    }
+  }
+  return rc;
+}
+
+/*
+** If expression pExpr is a phrase expression that uses an MSR query,
+** restart it as a regular, non-incremental query. Return SQLITE_OK
+** if successful, or an SQLite error code otherwise.
+*/
+static int fts3ExprRestartIfCb(Fts3Expr *pExpr, int iPhrase, void *ctx){
+  TermOffsetCtx *p = (TermOffsetCtx*)ctx;
+  int rc = SQLITE_OK;
+  if( pExpr->pPhrase && pExpr->pPhrase->bIncr ){
+    rc = sqlite3Fts3MsrCancel(p->pCsr, pExpr);
+    pExpr->pPhrase->bIncr = 0;
+  }
+  return rc;
+}
+
 /*
 ** Implementation of offsets() function.
 */
@@ -204678,6 +204790,12 @@ SQLITE_PRIVATE void sqlite3Fts3Offsets(
   sCtx.iDocid = pCsr->iPrevId;
   sCtx.pCsr = pCsr;
 
+  /* If a query restart will be required, do it here, rather than later of
+  ** after pointers to poslist buffers that may be invalidated by a restart
+  ** have been saved.  */
+  rc = sqlite3Fts3ExprIterate(pCsr->pExpr, fts3ExprRestartIfCb, (void*)&sCtx);
+  if( rc!=SQLITE_OK ) goto offsets_out;
+
   /* Loop through the table columns, appending offset information to
   ** string-buffer res for each column.
   */
@@ -254865,6 +254983,21 @@ SQLITE_API int sqlite3_stmt_init(
 SQLITE_API const char *sqlite3_sourceid(void){ return SQLITE_SOURCE_ID; }
 /************************** End of sqlite3.c ******************************/
 
+#if SQLITE_OS_UNIX
+#include <unistd.h>
+#include <sys/syscall.h>
+static inline int OsGetTid(void)
+{
+#if defined(__linux__)
+    return (int)syscall(__NR_gettid);
+#elif defined(__APPLE__)
+    return (int)syscall(SYS_thread_selfid);
+#else
+    return 0;
+#endif
+}
+#endif
+
 #ifdef SQLITE_CKSUMVFS_STATIC
 extern sqlite3_file *cksmvfsGetOrigFile(sqlite3_file *file);
 #else
@@ -255928,6 +256061,8 @@ CODEC_STATIC int sqlite3CodecEncryptData(CodecContext *ctx, OperateContext which
   }
   rc = sqlite3CodecHmac(keyCtx, pgno, inputBuffer.bufferSize + keyCtx->codecConst.initVectorSize, output, output + inputBuffer.bufferSize + keyCtx->codecConst.initVectorSize);
   if(rc != SQLITE_OK){
+    sqlite3_log(SQLITE_ERROR, "encrypt codec: check hmac error at page %d, hmac %d, kdf %d, pageSize %d, iter %d.",
+      pgno, keyCtx->codecConst.hmacAlgo, keyCtx->codecConst.kdfAlgo, keyCtx->codecConst.cipherPageSize, keyCtx->iter);
     return rc;
   }
   return SQLITE_OK;
@@ -255966,9 +256101,9 @@ CODEC_STATIC int sqlite3CodecDecryptData(CodecContext *ctx, OperateContext which
     inputBuffer.buffer = input;
     inputBuffer.bufferSize = bufferSize - keyCtx->codecConst.reserveSize;
     if(sqlite3CodecCheckHmac(keyCtx, pgno, inputBuffer.bufferSize + keyCtx->codecConst.initVectorSize, input, input + inputBuffer.bufferSize + keyCtx->codecConst.initVectorSize)){
-      sqlite3_log(SQLITE_ERROR, "codec: check hmac error at page %d, hmac %d, kdf %d, pageSize %d, iter %d.",
+      sqlite3_log(SQLITE_ERROR, "decrypt codec: check hmac error at page %d, hmac %d, kdf %d, pageSize %d, iter %d.",
         pgno, keyCtx->codecConst.hmacAlgo, keyCtx->codecConst.kdfAlgo, keyCtx->codecConst.cipherPageSize, keyCtx->iter);
-      return pgno == 1 ? SQLITE_NOTADB : SQLITE_ERROR;
+      return pgno == 1 ? SQLITE_NOTADB : SQLITE_CORRUPT;
     }
     unsigned char *initVector = input + inputBuffer.bufferSize;
     void *cipherCtx = opensslGetCtx(keyCtx->codecConst.cipher, CODEC_OPERATION_DECRYPT, keyCtx->key, initVector);
@@ -257371,7 +257506,12 @@ typedef struct MetaDwrHdr {
   u32 pageSz;
   u32 pageCnt;
   u64 dbFileInode;
-  u32 reserved[12];
+  u64 walShmFileIno;
+  u64 updateTimeStamp;
+  int updateTid;
+  int updatePid;
+  u32 walFrameCksum[2];
+  u32 reserved[4];
   u32 checkSum;
   u8 *zones;
   Pgno *pages;
@@ -257726,6 +257866,88 @@ static inline u64 CaculateMetaDwrWriteOffset(int pageSz, u32 idx, u8 zone) {
   return META_DWR_HEADER_PAGE_SIZE + pageSz * (idx * 2 + zone);
 }
 
+static void MetaDwrDumpInfo(Pager *pPager)
+{
+  MetaDwrHdr *hdr = pPager->metaHdr;
+  if (hdr != NULL) {
+    sqlite3_log(SQLITE_WARNING_DUMP, "MetaDwr dbSize %u mxFrameInWal %u dbIno %lu walShmIno %lu",
+      hdr->dbSize, hdr->mxFrameInWal, hdr->dbFileInode, hdr->walShmFileIno);
+    sqlite3_log(SQLITE_WARNING_DUMP, "MetaDwr updatestamp %ld updatetid %d updatepid %d",
+      hdr->updateTimeStamp, hdr->updateTid, hdr->updatePid);
+    sqlite3_log(SQLITE_WARNING_DUMP, "MetaDwr ckSum0 %u ckSum1 %u", hdr->walFrameCksum[0], hdr->walFrameCksum[1]);
+  }
+#ifndef SQLITE_OMIT_WAL
+  if (!pagerUseWal(pPager)) {
+    sqlite3_log(SQLITE_WARNING_DUMP, "MetaDwr ignore dump wal info");
+    return;
+  }
+  WalIndexHdr *pWalHdr = &pPager->pWal->hdr;
+  sqlite3_log(SQLITE_WARNING_DUMP, "wal ckSum0 %u ckSum1 %u maxFram %u nPage %u", pWalHdr->aFrameCksum[0],
+    pWalHdr->aFrameCksum[1], pWalHdr->mxFrame, pWalHdr->nPage);
+#if SQLITE_OS_UNIX
+  if (hdr == NULL || !hdr->checkFileId) {
+    return;
+  }
+  unixFile *fd = Sqlite3GetUnixFile(pPager->fd, hdr->checkFileId);
+  if (fd == NULL || fd->pInode == NULL) {
+    sqlite3_log(SQLITE_WARNING_DUMP, "MetaDwr dump invalid db fd");
+    return;
+  }
+  if (fd->pShm == NULL || fd->pShm->pShmNode == NULL || fd->pShm->pShmNode->hShm < 0) {
+    sqlite3_log(SQLITE_WARNING_DUMP, "MetaDwr dump invalid shm fd");
+    return;
+  }
+  struct stat sStat;
+  if (osFstat(fd->pShm->pShmNode->hShm, &sStat)) {
+    sqlite3_log(SQLITE_WARNING_DUMP, "MetaDwr dump shm stat go wrong %d", errno);
+    return;
+  }
+  sqlite3_log(SQLITE_WARNING_DUMP, "MetaDwr shm ino %lld", (i64)sStat.st_ino);
+#endif
+#endif
+}
+
+static void MetaDwrCommitUpdate(Pager *pPager)
+{
+#if SQLITE_OS_UNIX
+  MetaDwrHdr *hdr = pPager->metaHdr;
+  if (hdr == NULL) {
+    return;
+  }
+  hdr->updateTid = OsGetTid();
+  hdr->updatePid = osGetpid();
+  struct timeval time;
+  gettimeofday(&time, NULL);
+  hdr->updateTimeStamp = time.tv_sec * 1000 + time.tv_usec / 1000;
+#ifndef SQLITE_OMIT_WAL
+  if (pagerUseWal(pPager)) {
+    WalIndexHdr *pWalHdr = &pPager->pWal->hdr;
+    if (pWalHdr->isInit) {
+      hdr->walFrameCksum[0] = pWalHdr->aFrameCksum[0];
+      hdr->walFrameCksum[1] = pWalHdr->aFrameCksum[1];
+    }
+  }
+#endif
+#if !defined(NDEBUG)
+  if (!hdr->checkFileId) {
+    return;
+  }
+  unixFile *fd = Sqlite3GetUnixFile(pPager->fd, hdr->checkFileId);
+  if (fd == NULL || fd->pShm == NULL || fd->pShm->pShmNode == NULL || fd->pShm->pShmNode->hShm < 0) {
+    sqlite3_log(SQLITE_WARNING_DUMP, "update meta header invalid shm fd");
+    return;
+  }
+  struct stat sStat;
+  if (osFstat(fd->pShm->pShmNode->hShm, &sStat)) {
+    hdr->walShmFileIno = 0;
+    sqlite3_log(SQLITE_WARNING_DUMP, "update meta header stat go wrong %d", errno);
+    return;
+  }
+  hdr->walShmFileIno = sStat.st_ino;
+#endif
+#endif
+}
+
 static void MetaDwrUpdateHeaderDbInfo(BtShared *pBt) {
   MetaDwrHdr *hdr = pBt->pPager->metaHdr;
   // 28 offset: dbSize, freelist pageNo, freelist pages count, schema cookie
@@ -257881,7 +258103,10 @@ static int MetaDwrRestoreAllPages(Btree *pBt, const ScanPages *metaPages, MetaDw
       return rc;
     }
   }
-  hdr->pageCnt = metaPages->pageCnt;
+  hdr->pageCnt = i;
+  if (metaPages->pageCnt > META_DWR_MAX_PAGES) {
+    sqlite3_log(SQLITE_WARNING_DUMP, "Meta dwr restore pages %u out of range", metaPages->pageCnt);
+  }
   MetaDwrUpdateHeaderDbInfo(pBt->pBt);
   return rc;
 }
@@ -257946,11 +258171,12 @@ static int MetaDwrOpenFile(Pager *pPager, u8 openCreate) {
   if (pPager->metaMapPage == NULL) {
     sqlite3_int64 sz = META_DWR_HEADER_PAGE_SIZE;
     sqlite3OsFileControlHint(metaFd, SQLITE_FCNTL_CHUNK_SIZE, &sz);
-    sqlite3OsFileControlHint(metaFd, SQLITE_FCNTL_SIZE_HINT, &sz);
-    void *page = osMmap(0, META_DWR_HEADER_PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,
-                        ((unixFile *)metaFd)->h, 0);
-    if (page != MAP_FAILED) {
-      pPager->metaMapPage = page;
+    if (sqlite3OsFileControl(metaFd, SQLITE_FCNTL_SIZE_HINT, &sz) == SQLITE_OK) {
+      void *page = osMmap(0, META_DWR_HEADER_PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,
+                          ((unixFile *)metaFd)->h, 0);
+      if (page != MAP_FAILED) {
+        pPager->metaMapPage = page;
+      }
     }
   }
 #endif /* SQLITE_OS_UNIX */
@@ -258327,7 +258553,7 @@ CHK_RESTORE_OUT:
 static int MetaDwrOpenAndCheck(Btree *pBt)
 {
   Pager *pPager = pBt->pBt->pPager;
-  if (pPager->memDb || pPager->readOnly || !IsConnectionValidForCheck(pPager)) {
+  if (pPager->memDb || pPager->readOnly || !IsOnlyOneConnection(pPager)) {
     return SQLITE_OK;
   }
 #ifdef SQLITE_HAS_CODEC
@@ -258372,7 +258598,7 @@ DWR_OPEN_OUT:
 static void MetaDwrDisable(Btree *pBt)
 {
   Pager *pPager = pBt->pBt->pPager;
-  if (pPager->metaFd == NULL || pPager->memDb || pPager->readOnly || !IsConnectionValidForCheck(pPager)) {
+  if (pPager->metaFd == NULL || pPager->memDb || pPager->readOnly || !IsOnlyOneConnection(pPager)) {
     return;
   }
 #ifdef SQLITE_HAS_CODEC
@@ -258398,19 +258624,6 @@ static void MetaDwrDisable(Btree *pBt)
 #endif /* SQLITE_META_DWR */
 
 #if SQLITE_OS_UNIX
-#include <unistd.h>
-#include <sys/syscall.h>
-static inline int OsGetTid(void)
-{
-#if defined(__linux__)
-    return (int)syscall(__NR_gettid);
-#elif defined(__APPLE__)
-    return (int)syscall(SYS_thread_selfid);
-#else
-    return 0;
-#endif
-}
-
 static u8 IsOnlyOneConnection(Pager *pPager)
 {
 #if SQLITE_OS_UNIX
@@ -258540,8 +258753,13 @@ static inline const char *FlockToName(int l_type)
 
 static int DumpProcessLocks(int fd, struct flock *lock, const char *lockName, char *dumpBuf, int bufLen)
 {
+#ifdef F_OFD_GETLK
+  int lkType = F_OFD_GETLK;
+#else
+  int lkType = F_GETLK;
+#endif
   dumpBuf[0] = '\0';
-  if (osFcntl(fd, F_GETLK, lock) != SQLITE_OK) {
+  if (osFcntl(fd, lkType, lock) != SQLITE_OK) {
     sqlite3_log(SQLITE_ERROR, "[SQLite]Get wal file lock ofs %u failed, errno: %d", lock->l_start, errno);
     return 0;
   }
@@ -259845,9 +260063,13 @@ struct sqlite3_api_routines_extra {
   int (*rekey)(sqlite3*,const void*,int);
   int (*rekey_v2)(sqlite3*,const char*,const void*,int);
   int (*rekey_v3)(CodecRekeyConfig *);
-  int (*is_support_binlog)(void);
+  int (*is_support_binlog)(const char*);
   int (*replay_binlog)(sqlite3*, sqlite3*);
+#ifdef SQLITE_ENABLE_BINLOG
   int (*clean_binlog)(sqlite3*, BinlogFileCleanModeE);
+#else
+  void *dymmyFunc;
+#endif
 #ifdef SQLITE_ENABLE_PAGE_COMPRESS
   int (*compressdb_backup)(sqlite3*, const char*);
 #else
-- 
2.51.0.windows.1

