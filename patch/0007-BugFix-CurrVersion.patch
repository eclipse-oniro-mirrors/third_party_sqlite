From 4cb905b575c2103caada8386cb5fe35562059d4a Mon Sep 17 00:00:00 2001
From: ryne3366 <zengchuanrui@huawei.com>
Date: Mon, 24 Mar 2025 20:30:45 +0800
Subject: [PATCH] check permission for meta file

---
 src/sqlite3.c | 120 ++++++++++++++++++++++++++++++++++++++++----------
 1 file changed, 96 insertions(+), 24 deletions(-)

diff --git a/src/sqlite3.c b/src/sqlite3.c
index 7e9dcbf..d350cfc 100644
--- a/src/sqlite3.c
+++ b/src/sqlite3.c
@@ -45151,7 +45151,7 @@ static int unixOpen(
         flags |= SQLITE_OPEN_READONLY;
         openFlags |= O_RDONLY;
         isReadonly = 1;
-        sqlite3_log(SQLITE_WARNING, "Try open file readonly");
+        sqlite3_log(SQLITE_WARNING, "Try open file readonly sysno %d", errno);
         pReadonly = findReusableFd(zName, flags);
         if( pReadonly ){
           fd = pReadonly->fd;
@@ -70082,6 +70082,7 @@ SQLITE_PRIVATE int sqlite3WalFrames(
 ** If parameter xBusy is not NULL, it is a pointer to a busy-handler
 ** callback. In this case this function runs a blocking checkpoint.
 */
+static void walLogCheckpointInfo(Wal *pWal, sqlite3 *db, sqlite3_int64 startTime);
 SQLITE_PRIVATE int sqlite3WalCheckpoint(
   Wal *pWal,                      /* Wal connection */
   sqlite3 *db,                    /* Check this handle's interrupt flag */
@@ -70177,7 +70178,12 @@ SQLITE_PRIVATE int sqlite3WalCheckpoint(
           -1, 0, zMsg, NULL);
         rc = SQLITE_CORRUPT_REPORT(&context);
       }else{
-        rc = walCheckpoint(pWal, db, eMode2, xBusy2, pBusyArg, sync_flags,zBuf);
+        sqlite3_int64 startTime;
+        sqlite3OsCurrentTimeInt64(db->pVfs, &startTime);
+        rc = walCheckpoint(pWal, db, eMode2, xBusy2, pBusyArg, sync_flags, zBuf);
+        if (rc == SQLITE_OK){
+          walLogCheckpointInfo(pWal, db, startTime);
+        }
       }
 
       /* If no error occurred, set the output variables. */
@@ -205751,6 +205757,39 @@ static int fts3ExprTermOffsetInit(Fts3Expr *pExpr, int iPhrase, void *ctx){
   return rc;
 }
 
+/*
+** Expression node pExpr is an MSR phrase. This function restarts pExpr
+** so that it is a regular phrase query, not an MSR. SQLITE_OK is returned
+** if successful, or an SQLite error code otherwise.
+*/
+int sqlite3Fts3MsrCancel(Fts3Cursor *pCsr, Fts3Expr *pExpr){
+  int rc = SQLITE_OK;
+  if( pExpr->bEof==0 ){
+    i64 iDocid = pExpr->iDocid;
+    fts3EvalRestart(pCsr, pExpr, &rc);
+    while( rc==SQLITE_OK && pExpr->iDocid!=iDocid ){
+      fts3EvalNextRow(pCsr, pExpr, &rc);
+      if( pExpr->bEof ) rc = FTS_CORRUPT_VTAB;
+    }
+  }
+  return rc;
+}
+
+/*
+** If expression pExpr is a phrase expression that uses an MSR query,
+** restart it as a regular, non-incremental query. Return SQLITE_OK
+** if successful, or an SQLite error code otherwise.
+*/
+static int fts3ExprRestartIfCb(Fts3Expr *pExpr, int iPhrase, void *ctx){
+  TermOffsetCtx *p = (TermOffsetCtx*)ctx;
+  int rc = SQLITE_OK;
+  if( pExpr->pPhrase && pExpr->pPhrase->bIncr ){
+    rc = sqlite3Fts3MsrCancel(p->pCsr, pExpr);
+    pExpr->pPhrase->bIncr = 0;
+  }
+  return rc;
+}
+
 /*
 ** Implementation of offsets() function.
 */
@@ -205787,6 +205826,12 @@ SQLITE_PRIVATE void sqlite3Fts3Offsets(
   sCtx.iDocid = pCsr->iPrevId;
   sCtx.pCsr = pCsr;
 
+  /* If a query restart will be required, do it here, rather than later of
+  ** after pointers to poslist buffers that may be invalidated by a restart
+  ** have been saved.  */
+  rc = sqlite3Fts3ExprIterate(pCsr->pExpr, fts3ExprRestartIfCb, (void*)&sCtx);
+  if( rc!=SQLITE_OK ) goto offsets_out;
+
   /* Loop through the table columns, appending offset information to
   ** string-buffer res for each column.
   */
@@ -260390,7 +260435,7 @@ static int PragmaMetaDoubleWrie(sqlite3 *db, int iDb, Parse *parse, const char *
     sqlite3_mutex_enter(db->mutex);
     // only support enabled meta double write
     int rc = MetaDwrOpenAndCheck(pBt);
-    if (rc != SQLITE_OK) {
+    if (rc != SQLITE_OK && rc != SQLITE_PERM) {
       parse->nErr++;
       parse->rc = rc;
     }
@@ -260842,6 +260887,29 @@ static inline const char *GetMetaFilePath(Pager *pPager)
   return pPager->metaFd == NULL ? NULL : ((const char *)pPager->metaFd + ROUND8(pPager->pVfs->szOsFile));
 }
 
+static int MetaDwrCheckPerm(sqlite3_vfs *pVfs, u8 openCreate, char *metaPath) {
+  int exists = 0;
+  int rc = sqlite3OsAccess(pVfs, metaPath, SQLITE_ACCESS_EXISTS, &exists);
+  if (rc != SQLITE_OK) {
+    return rc;
+  }
+  if (!exists && !openCreate) {
+    return SQLITE_PERM;
+  }
+#ifdef HARMONY_OS
+  // check if the path have enough permission
+  rc = osAccess(metaPath, W_OK|R_OK);
+  if (rc == 0 || errno == ENOENT) {
+    return SQLITE_OK;
+  }
+  rc = SQLITE_PERM;
+  if (openCreate) {
+    sqlite3_log(SQLITE_WARNING_DUMP, "Meta double write disabled, sysno %d", errno);
+  }
+#endif
+  return rc;
+}
+
 static int MetaDwrOpenFile(Pager *pPager, u8 openCreate) {
   if (pPager->metaFd || pPager->zFilename == NULL) {
     return SQLITE_OK;
@@ -260858,15 +260926,10 @@ static int MetaDwrOpenFile(Pager *pPager, u8 openCreate) {
     return SQLITE_NOMEM_BKPT;
   }
   sqlite3_snprintf(size, metaPath, "%s-dwr", pPager->zFilename);
-  int exists = 0;
-  int rc = sqlite3OsAccess(pVfs, metaPath, SQLITE_ACCESS_EXISTS, &exists);
+  int rc = MetaDwrCheckPerm(pVfs, openCreate, metaPath);
   if (rc != SQLITE_OK) {
     goto INIT_META_OUT;
   }
-  if (!exists && !openCreate) {
-    sqlite3_free(metaFd);
-    goto INIT_META_OUT;
-  }
   u32 flags = (SQLITE_OPEN_READWRITE | SQLITE_OPEN_SUPER_JOURNAL);
   if (openCreate) {
     flags |= SQLITE_OPEN_CREATE;
@@ -261425,16 +261488,6 @@ static inline void MarkLockStatusByRc(int rc, u32 lockIdx, u32 lockLen, u8 lockT
   }
 }
 
-static inline const char *TrxLockName(int eLock)
-{
-  return eLock == NO_LOCK ? "NO_LOCK" :
-    eLock == RESERVED_LOCK ? "RESERVED" :
-    eLock == EXCLUSIVE_LOCK ? "EXCLUSIVE" :
-    eLock == SHARED_LOCK ? "SHARED" :
-    eLock == PENDING_LOCK ? "PENDING":
-    eLock == UNKNOWN_LOCK ? "UNKNOWN" : "UNKNOWN_LOCK";
-}
-
 static inline const char *IdxToLockName(u32 idx)
 {
   const char *lockName[MAX_LOCK_NUM] = {"write", "ckpt", "recover", "read0",
@@ -261451,7 +261504,7 @@ static void DumpHandleLock(char *dumpBuf, int dumpBufLen)
   for (int i = 0; i < MAX_LOCK_NUM && availLen > DUMP_MAX_STR_LEN; i++) {
     if (lockStatus[i] != NO_LOCK) {
       tmp[0] = '\0';
-      sqlite3_snprintf(availLen, tmp, "<%s, %s>", IdxToLockName((u32)i), TrxLockName(lockStatus[i]));
+      sqlite3_snprintf(availLen, tmp, "<%s, %d>", IdxToLockName((u32)i), lockStatus[i]);
       int len = strlen(tmp);
       tmp += len;
       availLen -= len;
@@ -261490,8 +261543,8 @@ static void DumpTrxProcessLocks(unixFile *file, char *dumpBuf, int dumpBufLen)
     sqlite3_log(SQLITE_ERROR, "[SQLite]Inode is null!");
     return;
   }
-  sqlite3_log(SQLITE_WARNING_DUMP, "[SQLite]acqLock:%s, dbRef:%d, lockCnt:%d, curLock:%s, processLock:%d",
-    TrxLockName(file->eFileLock), inode->nRef, inode->nLock, TrxLockName(inode->eFileLock), inode->bProcessLock);
+  sqlite3_log(SQLITE_WARNING_DUMP, "[SQLite]acqLock:%d, dbRef:%d, lockCnt:%d, curLock:%d, processLock:%d",
+    file->eFileLock, inode->nRef, inode->nLock, inode->eFileLock, inode->bProcessLock);
   const char *lockName[DB_LOCK_NUM] = {"pending", "reserved", "shared_first"};
   char *tmp = dumpBuf;
   int availLen = dumpBufLen - 1;
@@ -261511,10 +261564,13 @@ static void DumpTrxProcessLocks(unixFile *file, char *dumpBuf, int dumpBufLen)
 
 static void DumpWalLocks(unixFile *file, u8 walEnabled, char *dumpBuf, int dumpBufLen)
 {
-  if (!walEnabled || file->pShm == NULL || file->pShm->pShmNode == NULL) {
-    sqlite3_log(SQLITE_ERROR, "[SQLite]Wal mode disabled!");
+  if (file->pShm == NULL || file->pShm->pShmNode == NULL) {
+    sqlite3_log(SQLITE_ERROR, "[SQLite]Wal mode disabled! pShm or pShmNode is NULL");
     return;
   }
+  if (!walEnabled) {
+    sqlite3_log(SQLITE_ERROR, "[SQLite] walEnabled false");
+  }
   unixShmNode *pShmNode = file->pShm->pShmNode;
   char *tmp = dumpBuf;
   int availLen = dumpBufLen - 1;
@@ -261583,6 +261639,22 @@ static void DumpLocksByPager(Pager *pPager)
 }
 #endif /* SQLITE_OS_UNIX */
 
+static void walLogCheckpointInfo(Wal *pWal, sqlite3 *db, sqlite3_int64 startTime) {
+  sqlite3_int64 endTime;
+  sqlite3OsCurrentTimeInt64(db->pVfs, &endTime);
+  sqlite3_int64 timeUse = endTime - startTime;
+  static sqlite3_int64 lastDumpTime = 0;
+  static sqlite3_int64 ckptCnt = 0;
+  /* Only when timeUse > 1500ms or wal size > 50MB, default pageSize 4K, 50*1024/4 = 12800 */
+  if (timeUse > 1500 || (pWal->hdr.mxFrame > 12800 && (lastDumpTime - endTime) > 2000)) {
+    sqlite3_log(SQLITE_WARNING_DUMP, "[SQLite]Wal try ckpt count %d use time: %lld(ms), wal frame: %u",
+                ckptCnt, timeUse, pWal->hdr.mxFrame);
+    lastDumpTime = endTime;
+    ckptCnt = 0;
+  }
+  ckptCnt++;
+}
+
 // hw export the symbols
 #ifdef SQLITE_EXPORT_SYMBOLS
 #ifndef SQLITE_CKSUMVFS_STATIC
-- 
2.34.1

