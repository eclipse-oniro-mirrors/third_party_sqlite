From 8d979f06d87d2a789dc4c3345a8c4444505e64cd Mon Sep 17 00:00:00 2001
From: ryne3366 <ryne3366@noreply.gitcode.com>
Date: Thu, 18 Sep 2025 17:28:51 +0800
Subject: [PATCH 1/2] enhance rekey

---
 src/sqlite3.c | 1248 ++++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 1021 insertions(+), 227 deletions(-)

diff --git a/src/sqlite3.c b/src/sqlite3.c
index 02885e0..30b9daf 100644
--- a/src/sqlite3.c
+++ b/src/sqlite3.c
@@ -17631,16 +17631,17 @@ SQLITE_PRIVATE void sqlite3CryptFunc(sqlite3_context*,int,sqlite3_value**);
 typedef void (*sqlite3_xDropTableHandle)(sqlite3*, const char*, const char*);
 #endif /* SQLITE_ENABLE_DROPTABLE_CALLBACK */
 
-#if defined(SQLITE_HAS_CODEC) && defined(SQLITE_CODEC_ATTACH_CHANGED)
+#if defined(SQLITE_HAS_CODEC)
 typedef struct CodecParameter {
   int kdfIter;
   int pageSize;
+  int reserveSize;
   u8 cipher;
   u8 hmacAlgo;
   u8 kdfAlgo;
   u8 reserved;
 } CodecParameter;
-#endif /* defined(SQLITE_HAS_CODEC) && defined(SQLITE_CODEC_ATTACH_CHANGED) */
+#endif /* defined(SQLITE_HAS_CODEC) */
 
 #ifdef SQLITE_ENABLE_BINLOG
 /************** Begin of the header file of binlog ************************************/
@@ -17988,9 +17989,9 @@ struct sqlite3 {
   char *mDropSchemaName;
   sqlite3_xDropTableHandle xDropTableHandle;        /* User drop table callback */
 #endif /* SQLITE_ENABLE_DROPTABLE_CALLBACK */
-#if defined(SQLITE_HAS_CODEC) && defined(SQLITE_CODEC_ATTACH_CHANGED)
-  CodecParameter codecParm;
-#endif /* defined(SQLITE_HAS_CODEC) && defined(SQLITE_CODEC_ATTACH_CHANGED) */
+#if defined(SQLITE_HAS_CODEC)
+  CodecParameter codecParm[2]; // 1:default codec 2:rekey codec
+#endif /* defined(SQLITE_HAS_CODEC) */
 #ifdef SQLITE_ENABLE_BINLOG
   Sqlite3BinlogHandle xBinlogHandle;
 #endif
@@ -21143,12 +21144,11 @@ SQLITE_PRIVATE int sqlite3ParseUri(const char*,const char*,unsigned int*,
                     sqlite3_vfs**,char**,char **);
 #ifdef SQLITE_HAS_CODEC
 SQLITE_PRIVATE   int sqlite3CodecQueryParameters(sqlite3*,const char*,const char*);
+SQLITE_PRIVATE void sqlite3CodecResetParameters(CodecParameter *p);
 #else
 # define sqlite3CodecQueryParameters(A,B,C) 0
 #endif /* SQLITE_HAS_CODEC */
-#if defined(SQLITE_HAS_CODEC) && defined(SQLITE_CODEC_ATTACH_CHANGED)
-SQLITE_PRIVATE void sqlite3CodecResetParameters(CodecParameter *p);
-#endif /* defined(SQLITE_HAS_CODEC) && defined(SQLITE_CODEC_ATTACH_CHANGED) */
+
 SQLITE_PRIVATE Btree *sqlite3DbNameToBtree(sqlite3*,const char*);
 
 #ifdef SQLITE_UNTESTABLE
@@ -38699,10 +38699,11 @@ struct unixFile {
 #endif
 };
 
-#ifdef SQLITE_HAS_CODEC
+#if defined(SQLITE_HAS_CODEC) && SQLITE_OS_UNIX
 static int CodecFileLock(Pager *pPager, short lockType);
+static int CodecCheckRecoverRekey(const char *dbPath);
 #endif
-
+static u8 IsOnlyOneConnection(Pager *pPager);
 /* This variable holds the process id (pid) from when the xRandomness()
 ** method was called.  If xOpen() is called from a different process id,
 ** indicating that a fork() has occurred, the PRNG will be reset.
@@ -44877,6 +44878,14 @@ static int unixOpen(
 #endif
 
   if( eType==SQLITE_OPEN_MAIN_DB ){
+#if defined(SQLITE_HAS_CODEC) && SQLITE_OS_UNIX
+    sqlite3BeginBenignMalloc();
+    rc = CodecCheckRecoverRekey(zName);
+    sqlite3EndBenignMalloc();
+    if (rc != SQLITE_OK) {
+      return rc;
+    }
+#endif
     UnixUnusedFd *pUnused;
     pUnused = findReusableFd(zName, flags);
     if( pUnused ){
@@ -44888,7 +44897,6 @@ static int unixOpen(
       }
     }
     p->pPreallocatedUnused = pUnused;
-
     /* Database filenames are double-zero terminated if they are not
     ** URIs with parameters.  Hence, they can always be passed into
     ** sqlite3_uri_parameter(). */
@@ -44928,6 +44936,7 @@ static int unixOpen(
       assert( eType==SQLITE_OPEN_WAL || eType==SQLITE_OPEN_MAIN_JOURNAL );
       return rc;
     }
+
     fd = robust_open(zName, openFlags, openMode);
     OSTRACE(("OPENX   %-3d %s 0%o\n", fd, zName, openFlags));
     assert( !isExclusive || (openFlags & O_CREAT)!=0 );
@@ -61893,7 +61902,7 @@ SQLITE_PRIVATE int sqlite3PagerClose(Pager *pPager, sqlite3 *db){
   IOTRACE(("CLOSE %p\n", pPager))
   sqlite3OsClose(pPager->jfd);
 #if SQLITE_OS_UNIX && defined(SQLITE_HAS_CODEC)
-  if( pPager->xCodec ) CodecFileLock(pPager, F_UNLCK);
+  CodecFileLock(pPager, F_UNLCK);
 #endif
   sqlite3OsClose(pPager->fd);
   sqlite3PageFree(pTmp);
@@ -62748,9 +62757,14 @@ act_like_temp_file:
                        !memDb?pagerStress:0, (void *)pPager, pPager->pPCache);
   }
 #ifdef SQLITE_META_DWR
-  if( rc==SQLITE_OK && !memDb && !readOnly){
+  if(rc==SQLITE_OK && !memDb && !readOnly){
     (void)MetaDwrOpenFile(pPager, 0);
   }
+#endif
+#if SQLITE_OS_UNIX && defined(SQLITE_HAS_CODEC)
+  if(rc==SQLITE_OK && !memDb && (rc = CodecFileLock(pPager, F_RDLCK)) != SQLITE_OK){
+    sqlite3_log(rc, "[rekey]File shared lock: error when open DB.");
+  }
 #endif
   /* If an error occurred above, free the  Pager structure and close the file.
   */
@@ -64899,6 +64913,20 @@ SQLITE_PRIVATE void sqlite3PagerSetCodec(
   setGetterMethod(pPager);
   pagerReportSize(pPager);
 }
+SQLITE_PRIVATE void sqlite3PagerClearCodec(Pager *pPager)
+{
+  if( pPager->xCodecFree ){
+    pPager->xCodecFree(pPager->pCodec);
+  }else{
+    pager_reset(pPager);
+  }
+  pPager->xCodec = 0;
+  pPager->xCodecSizeChng = 0;
+  pPager->xCodecFree = 0;
+  pPager->pCodec = 0;
+  setGetterMethod(pPager);
+  pagerReportSize(pPager);
+}
 SQLITE_PRIVATE void *sqlite3PagerGetCodec(Pager *pPager){
   return pPager->pCodec;
 }
@@ -184186,9 +184214,8 @@ opendb_out:
 #endif
 #ifdef SQLITE_HAS_CODEC
   if( rc==SQLITE_OK ) {
-#ifdef SQLITE_CODEC_ATTACH_CHANGED
-    sqlite3CodecResetParameters(&db->codecParm);
-#endif /* SQLITE_CODEC_ATTACH_CHANGED */
+    sqlite3CodecResetParameters(&db->codecParm[0]);
+    sqlite3CodecResetParameters(&db->codecParm[1]);
     sqlite3CodecQueryParameters(db, 0, zOpen);
   }
 #endif /* SQLITE_HAS_CODEC */
@@ -254925,7 +254952,6 @@ typedef struct{
   int reserveSize;
   int hmacAlgo;
   int kdfAlgo;
-  int rekeyHmacAlgo;
 }CodecConstant;
 
 typedef struct{
@@ -255026,6 +255052,7 @@ CODEC_STATIC int opensslGetInitVectorSize(void *cipher){
   return EVP_CIPHER_iv_length((EVP_CIPHER *)cipher);
 }
 
+#define CIPHER_HMAC_ALGORITHM_INVALID 0
 #define CIPHER_HMAC_ALGORITHM_SHA1 1
 #define CIPHER_HMAC_ALGORITHM_SHA256 2
 #define CIPHER_HMAC_ALGORITHM_SHA512 3
@@ -255036,6 +255063,7 @@ CODEC_STATIC int opensslGetInitVectorSize(void *cipher){
 #define CIPHER_HMAC_ALGORITHM_NAME_SHA256 "SHA256"
 #define CIPHER_HMAC_ALGORITHM_NAME_SHA512 "SHA512"
 
+#define CIPHER_KDF_ALGORITHM_INVALID 0
 #define CIPHER_KDF_ALGORITHM_SHA1 1
 #define CIPHER_KDF_ALGORITHM_SHA256 2
 #define CIPHER_KDF_ALGORITHM_SHA512 3
@@ -255046,21 +255074,24 @@ CODEC_STATIC int opensslGetInitVectorSize(void *cipher){
 #define CIPHER_KDF_ALGORITHM_NAME_SHA256 "KDF_SHA256"
 #define CIPHER_KDF_ALGORITHM_NAME_SHA512 "KDF_SHA512"
 
-
-CODEC_STATIC int opensslGetHmacSize(KeyContext *keyCtx){
-  if( keyCtx==NULL ){
-    return 0;
-  }
-  if( keyCtx->codecConst.hmacAlgo==CIPHER_HMAC_ALGORITHM_SHA1 ){
+CODEC_STATIC int GetHmacSize(int hmacAlgo){
+  if( hmacAlgo==CIPHER_HMAC_ALGORITHM_SHA1 ){
     return EVP_MD_size(EVP_sha1());
-  }else if( keyCtx->codecConst.hmacAlgo==CIPHER_HMAC_ALGORITHM_SHA256 ){
+  }else if( hmacAlgo==CIPHER_HMAC_ALGORITHM_SHA256 ){
     return EVP_MD_size(EVP_sha256());
-  }else if( keyCtx->codecConst.hmacAlgo==CIPHER_HMAC_ALGORITHM_SHA512 ){
+  }else if( hmacAlgo==CIPHER_HMAC_ALGORITHM_SHA512 ){
     return EVP_MD_size(EVP_sha512());
   }
   return 0;
 }
 
+CODEC_STATIC int opensslGetHmacSize(KeyContext *keyCtx){
+  if( keyCtx==NULL ){
+    return 0;
+  }
+  return GetHmacSize(keyCtx->codecConst.hmacAlgo);
+}
+
 CODEC_STATIC int opensslGetBlockSize(void *cipher){
   return EVP_CIPHER_block_size((EVP_CIPHER *)cipher);
 }
@@ -255198,6 +255229,7 @@ CODEC_STATIC int sqlite3CodecIsKeyInfoFormat(const unsigned char *input, int inp
 CODEC_STATIC void sqlite3CodecSetError(CodecContext *ctx, int error){
   if(ctx->pBt){
     ctx->pBt->pBt->pPager->errCode = error;
+    ctx->pBt->pBt->pPager->eState = PAGER_ERROR;
     ctx->pBt->pBt->db->errCode = error;
   }
   return;
@@ -255256,6 +255288,9 @@ CODEC_STATIC int sqlite3CodecKeyCtxCmp(KeyContext *first, KeyContext *second){
 
 // This function will free all resources of key context, except it self.
 CODEC_STATIC void sqlite3CodecFreeKeyContext(KeyContext *keyCtx){
+  if (keyCtx == NULL) {
+    return;
+  }
   sqlite3CodecClearDeriveKey(keyCtx);
   sqlite3CodecClearPassword(keyCtx);
   (void)opensslFreeCipher(keyCtx->codecConst.cipher);
@@ -255391,7 +255426,8 @@ CODEC_STATIC int sqlite3CodecDeriveKey(CodecContext *ctx, OperateContext whichKe
   hmacKey.bufferSize = keyCtx->codecConst.keySize;
   opensslKdf(&hmacPassword, &hmacSalt, HMAC_ITER, &hmacKey, keyCtx->codecConst.kdfAlgo);
   keyCtx->deriveFlag = 1;
-  if(sqlite3CodecKeyCtxCmp(keyCtx, secondKeyCtx)){
+  // rekey may holds null secondKeyCtx
+  if(secondKeyCtx != NULL && sqlite3CodecKeyCtxCmp(keyCtx, secondKeyCtx)){
     sqlite3CodecClearDeriveKey(secondKeyCtx);
     int rc = sqlite3CodecCopyDeriveKey(keyCtx, secondKeyCtx);
     if(rc == SQLITE_OK){
@@ -255435,9 +255471,9 @@ CODEC_STATIC int sqlite3CodecSetIter(KeyContext *keyCtx, int iter){
   return SQLITE_OK;
 }
 
-#ifdef SQLITE_CODEC_ATTACH_CHANGED
 #define CIPHER_ID_AES_256_CBC 0
 #define CIPHER_ID_AES_256_GCM 1
+#define CIPHER_ID_INVALID 2
 
 #define CIPHER_TOTAL_NUM 2
 
@@ -255454,26 +255490,100 @@ static const struct CodecCipherNameId g_cipherNameIdMap[CIPHER_TOTAL_NUM] = {
   { CIPHER_ID_AES_256_GCM, CIPHER_NAME_AES_256_GCM }
 };
 
+#define HMAC_ALGO_NUM 3
+
+struct HmacAlgoParam {
+  int hmacAlgo;
+  int kdfAlgo;
+  const char *hmacAlgoName;
+  const char *kdfAlgoName;
+};
+
+static const struct HmacAlgoParam g_AlgoMap[HMAC_ALGO_NUM] = {
+  { CIPHER_HMAC_ALGORITHM_SHA1, CIPHER_KDF_ALGORITHM_SHA1, CIPHER_HMAC_ALGORITHM_NAME_SHA1,
+    CIPHER_KDF_ALGORITHM_NAME_SHA1 },
+  { CIPHER_HMAC_ALGORITHM_SHA256, CIPHER_KDF_ALGORITHM_SHA256, CIPHER_HMAC_ALGORITHM_NAME_SHA256,
+    CIPHER_KDF_ALGORITHM_NAME_SHA256 },
+  { CIPHER_HMAC_ALGORITHM_SHA512, CIPHER_KDF_ALGORITHM_SHA512, CIPHER_HMAC_ALGORITHM_NAME_SHA512,
+    CIPHER_KDF_ALGORITHM_NAME_SHA512 }
+};
+
+SQLITE_PRIVATE int HmacName2Algo(const char *hmacName)
+{
+  for (int i = 0; i < HMAC_ALGO_NUM; i++) {
+    if (sqlite3_stricmp(hmacName, g_AlgoMap[i].hmacAlgoName) == 0){
+      return g_AlgoMap[i].hmacAlgo;
+    }
+  }
+  return CIPHER_HMAC_ALGORITHM_INVALID;
+}
+
+SQLITE_PRIVATE const char *Algo2HmacName(int algo)
+{
+  if (unlikely(algo <= 0 || algo > HMAC_ALGO_NUM)) {
+    return NULL;
+  }
+  return g_AlgoMap[algo - 1].hmacAlgoName;
+}
+
+SQLITE_PRIVATE int KdfName2Algo(const char *kdfName)
+{
+  for (int i = 0; i < HMAC_ALGO_NUM; i++) {
+    if (sqlite3_stricmp(kdfName, g_AlgoMap[i].kdfAlgoName) == 0){
+      return g_AlgoMap[i].kdfAlgo;
+    }
+  }
+  return CIPHER_KDF_ALGORITHM_INVALID;
+}
+
+SQLITE_PRIVATE const char *Algo2KdfName(int algo)
+{
+  if (unlikely(algo <= 0 || algo > HMAC_ALGO_NUM)) {
+    return NULL;
+  }
+  return g_AlgoMap[algo - 1].kdfAlgoName;
+}
+
+SQLITE_PRIVATE int CipherName2CipherId(const char *cipherName)
+{
+  int i;
+  for( i=0; i<CIPHER_TOTAL_NUM; i++ ){
+    if( sqlite3StrICmp(cipherName, g_cipherNameIdMap[i].cipherName)==0 ){
+      return g_cipherNameIdMap[i].cipherId;
+    }
+  }
+  return CIPHER_ID_INVALID;
+}
+
 SQLITE_PRIVATE void sqlite3CodecResetParameters(CodecParameter *p)
 {
   p->kdfIter = DEFAULT_ITER;
   p->pageSize = DEFAULT_PAGE_SIZE;
+  p->reserveSize = 0;
   p->cipher = CIPHER_ID_AES_256_GCM;
   p->hmacAlgo = DEFAULT_HMAC_ALGORITHM;
   p->kdfAlgo = DEFAULT_KDF_ALGORITHM;
 }
 
-CODEC_STATIC void sqlite3CodecSetDefaultAttachCipher(CodecParameter *parm, const char *cipherName){
+CODEC_STATIC CodecParameter *sqlite3CodecGetDedaultParameters(void)
+{
+  static CodecParameter parm = { DEFAULT_ITER, DEFAULT_PAGE_SIZE, 0, CIPHER_ID_AES_256_GCM, DEFAULT_HMAC_ALGORITHM,
+    DEFAULT_KDF_ALGORITHM, 0 };
+  return &parm;
+}
+
+CODEC_STATIC int sqlite3CodecSetDefaultAttachCipher(CodecParameter *parm, const char *cipherName){
   int i;
   for( i=0; i<CIPHER_TOTAL_NUM; i++ ){
     if( sqlite3StrICmp(cipherName, g_cipherNameIdMap[i].cipherName)==0 ){
       sqlite3_mutex_enter(sqlite3_mutex_alloc(SQLITE_MUTEX_STATIC_MASTER));
       parm->cipher = g_cipherNameIdMap[i].cipherId;
       sqlite3_mutex_leave(sqlite3_mutex_alloc(SQLITE_MUTEX_STATIC_MASTER));
-      return;
+      return SQLITE_OK;
     }
   }
   sqlite3_log(SQLITE_WARNING, "invalid attach cipher algorithm");
+  return SQLITE_ERROR;
 }
 
 CODEC_STATIC const char *sqlite3CodecGetDefaultAttachCipher(CodecParameter *parm){
@@ -255486,13 +255596,14 @@ CODEC_STATIC const char *sqlite3CodecGetDefaultAttachCipher(CodecParameter *parm
   return attachedCipher;
 }
 
-CODEC_STATIC void sqlite3CodecSetDefaultAttachKdfIter(CodecParameter *parm, int iter){
+CODEC_STATIC int sqlite3CodecSetDefaultAttachKdfIter(CodecParameter *parm, int iter){
   if( iter<=0 ){
-    return;
+    return SQLITE_ERROR;
   }
   sqlite3_mutex_enter(sqlite3_mutex_alloc(SQLITE_MUTEX_STATIC_MASTER));
   parm->kdfIter = iter;
   sqlite3_mutex_leave(sqlite3_mutex_alloc(SQLITE_MUTEX_STATIC_MASTER));
+  return SQLITE_OK;
 }
 
 CODEC_STATIC int sqlite3CodecGetDefaultAttachKdfIter(CodecParameter *parm){
@@ -255541,8 +255652,6 @@ CODEC_STATIC int sqlite3CodecGetDefaultAttachPageSize(CodecParameter *parm){
   return pageSize;
 }
 
-#endif /* SQLITE_CODEC_ATTACH_CHANGED */
-
 // You should clear key derive infos and password infos before you call this function
 CODEC_STATIC int sqlite3CodecSetPassword(KeyContext *keyCtx, const void *zKey, int nKey){
   keyCtx->passwordSize = nKey;
@@ -255581,9 +255690,17 @@ CODEC_STATIC int sqlite3CodecSetKdfAlgorithm(KeyContext *keyCtx, int kdfAlgo){
   return SQLITE_OK;
 }
 
-CODEC_STATIC int sqlite3CodecSetCipherPageSize(CodecContext *ctx, int size){
+CODEC_STATIC int CodecPageSizeValid(int size)
+{
   if(!((size != 0) && ((size & (size - 1)) == 0)) || size < 512 || size > 65536) {
     sqlite3_log(SQLITE_ERROR, "codec: cipher_page_size not a power of 2 and between 512 and 65536 inclusive(%d).", size);
+    return 0;
+  }
+  return 1;
+}
+
+CODEC_STATIC int sqlite3CodecSetCipherPageSize(CodecContext *ctx, int size){
+  if(!CodecPageSizeValid(size)) {
     return SQLITE_ERROR;
   }
   int cipherPageSize = ctx->readCtx->codecConst.cipherPageSize;
@@ -255622,48 +255739,30 @@ CODEC_STATIC int sqlite3CodecCopyKeyContext(KeyContext *input, KeyContext *outpu
 }
 
 // You should clear key context before you call this function
-#ifdef SQLITE_CODEC_ATTACH_CHANGED
-CODEC_STATIC int sqlite3CodecInitKeyContext(CodecContext *ctx, Btree *p, const void *zKey, int nKey, int attachFlag){
-#else
-CODEC_STATIC int sqlite3CodecInitKeyContext(CodecContext *ctx, Btree *p, const void *zKey, int nKey){
-#endif /* SQLITE_CODEC_ATTACH_CHANGED */
+CODEC_STATIC int sqlite3CodecInitKeyContext(CodecContext *ctx, Btree *p, const void *zKey, int nKey, CodecParameter *parm){
   int rc = SQLITE_OK;
   KeyContext *keyCtx = ctx->readCtx;
-#ifdef SQLITE_CODEC_ATTACH_CHANGED
-  if( attachFlag!=0 ){
-    CodecParameter *parm = &p->db->codecParm;
-    int hmacAlgo = sqlite3CodecGetDefaultAttachHmacAlgo(parm);
-    rc = sqlite3CodecSetCodecConstant(keyCtx, sqlite3CodecGetDefaultAttachCipher(parm));
-    rc += sqlite3CodecSetIter(keyCtx, sqlite3CodecGetDefaultAttachKdfIter(parm));
-    if( hmacAlgo!=0 ){
-      rc += sqlite3CodecSetHmacAlgorithm(keyCtx, hmacAlgo);
-    }
-    int attachKdfAlgo = sqlite3CodecGetDefaultAttachKdfAlgo(parm);
-    if( attachKdfAlgo!=0 ){
-      rc += sqlite3CodecSetKdfAlgorithm(keyCtx, attachKdfAlgo);
-    }
-    int cipherPageSize = sqlite3CodecGetDefaultAttachPageSize(parm);
-    if( cipherPageSize!=0 ){
-      rc += sqlite3CodecSetCipherPageSize(ctx, cipherPageSize);
-      if ( rc != SQLITE_OK ) {
-        sqlite3CodecFreeKeyContext(keyCtx);
-        return SQLITE_ERROR;
-      }
-      rc += sqlite3BtreeSetPageSize(p, cipherPageSize, keyCtx->codecConst.reserveSize, 0);
+  int hmacAlgo = sqlite3CodecGetDefaultAttachHmacAlgo(parm);
+  rc = sqlite3CodecSetCodecConstant(keyCtx, sqlite3CodecGetDefaultAttachCipher(parm));
+  rc += sqlite3CodecSetIter(keyCtx, sqlite3CodecGetDefaultAttachKdfIter(parm));
+  if( hmacAlgo!=0 ){
+    rc += sqlite3CodecSetHmacAlgorithm(keyCtx, hmacAlgo);
+  }
+  int attachKdfAlgo = sqlite3CodecGetDefaultAttachKdfAlgo(parm);
+  if( attachKdfAlgo!=0 ){
+    rc += sqlite3CodecSetKdfAlgorithm(keyCtx, attachKdfAlgo);
+  }
+  int cipherPageSize = sqlite3CodecGetDefaultAttachPageSize(parm);
+  if( cipherPageSize!=0 ){
+    rc += sqlite3CodecSetCipherPageSize(ctx, cipherPageSize);
+    if ( rc != SQLITE_OK ) {
+      sqlite3CodecFreeKeyContext(keyCtx);
+      return SQLITE_ERROR;
     }
-  }else{
-    rc = sqlite3CodecSetCodecConstant(keyCtx, DEFAULT_CIPHER);
-    rc += sqlite3CodecSetIter(keyCtx, DEFAULT_ITER);
-    rc += sqlite3CodecSetHmacAlgorithm(keyCtx, DEFAULT_HMAC_ALGORITHM);
-    rc += sqlite3CodecSetKdfAlgorithm(keyCtx, DEFAULT_KDF_ALGORITHM);
+    p->pBt->btsFlags &= ~BTS_PAGESIZE_FIXED;
+    rc += sqlite3BtreeSetPageSize(p, cipherPageSize, keyCtx->codecConst.reserveSize, 0);
+    p->pBt->btsFlags |= BTS_PAGESIZE_FIXED;
   }
-#else
-  rc = sqlite3CodecSetCodecConstant(keyCtx, DEFAULT_CIPHER);
-  rc += sqlite3CodecSetIter(keyCtx, DEFAULT_ITER);
-  rc += sqlite3CodecSetHmacAlgorithm(keyCtx, DEFAULT_HMAC_ALGORITHM);
-  rc += sqlite3CodecSetKdfAlgorithm(keyCtx, DEFAULT_KDF_ALGORITHM);
-#endif /* SQLITE_CODEC_ATTACH_CHANGED */
-  keyCtx->codecConst.rekeyHmacAlgo = DEFAULT_HMAC_ALGORITHM;
   rc += sqlite3CodecSetPassword(keyCtx, zKey, nKey);
   if(rc != SQLITE_OK){
     sqlite3CodecFreeKeyContext(keyCtx);
@@ -255693,15 +255792,9 @@ CODEC_STATIC void sqlite3CodecFreeContext(CodecContext *ctx){
   (void)memset_s(ctx, sizeof(CodecContext), 0, sizeof(CodecContext));
   return;
 }
-#ifdef SQLITE_CODEC_ATTACH_CHANGED
-CODEC_STATIC int sqlite3CodecInitContext(CodecContext *ctx, Btree *p, const void *zKey, int nKey, int nDb){
-  int attachFlag = (nDb > 1) ? 1 : 0;
-  int defaultPageSz = attachFlag ? p->db->codecParm.pageSize : DEFAULT_PAGE_SIZE;
-#else
-CODEC_STATIC int sqlite3CodecInitContext(CodecContext *ctx, Btree *p, const void *zKey, int nKey){
-  int defaultPageSz = DEFAULT_PAGE_SIZE;
-#endif /* SQLITE_CODEC_ATTACH_CHANGED */
-  sqlite3_file *fd = p->pBt->pPager->fd;
+
+CODEC_STATIC int sqlite3CodecInitContext(CodecContext *ctx, Btree *p, const void *zKey, int nKey, CodecParameter *parm){
+  int defaultPageSz = parm->pageSize;
   ctx->pBt = p;
   ctx->savePassword = 0;
   ctx->buffer = (unsigned char *)sqlite3Malloc(defaultPageSz);
@@ -255720,11 +255813,7 @@ CODEC_STATIC int sqlite3CodecInitContext(CodecContext *ctx, Btree *p, const void
   }
   ctx->readCtx->codecConst.cipherPageSize = defaultPageSz;
   ctx->writeCtx->codecConst.cipherPageSize = defaultPageSz;
-#ifdef SQLITE_CODEC_ATTACH_CHANGED
-  int rc = sqlite3CodecInitKeyContext(ctx, p, zKey, nKey, attachFlag);
-#else
-  int rc = sqlite3CodecInitKeyContext(ctx, p, zKey, nKey);
-#endif /* SQLITE_CODEC_ATTACH_CHANGED */
+  int rc = sqlite3CodecInitKeyContext(ctx, p, zKey, nKey, parm);
   if(rc != SQLITE_OK){
     sqlite3CodecFreeContext(ctx);
     return SQLITE_ERROR;
@@ -255734,16 +255823,6 @@ CODEC_STATIC int sqlite3CodecInitContext(CodecContext *ctx, Btree *p, const void
     sqlite3CodecFreeContext(ctx);
     return SQLITE_ERROR;
   }
-  if(fd == NULL || !(isOpen(fd)) || sqlite3OsRead(fd, ctx->salt, SALT_SIZE, 0) != SQLITE_OK){
-    Buffer salt;
-    salt.buffer = ctx->salt;
-    salt.bufferSize = SALT_SIZE;
-    rc = opensslGetRandom(&salt);
-    if(rc != SQLITE_OK){
-      sqlite3CodecFreeContext(ctx);
-      return rc;
-    }
-  }
   return SQLITE_OK;
 }
 
@@ -255933,11 +256012,15 @@ void* sqlite3Codec(void *ctx, void *data, Pgno pgno, int mode){
   if(pgno == 1){
     offset = FILE_HEADER_SIZE;
   }
-  int cipherPageSize = pCtx->readCtx->codecConst.cipherPageSize;
+  int cipherPageSize = DEFAULT_PAGE_SIZE;
   switch(mode){
     case 0:
     case 2:
     case 3:
+      if (pCtx->readCtx == NULL) {
+        return pData;
+      }
+      cipherPageSize = pCtx->readCtx->codecConst.cipherPageSize;
       if(pgno == 1){
         memcpyRc = memcpy_s(pCtx->buffer, cipherPageSize, SQLITE_FILE_HEADER, FILE_HEADER_SIZE);
         if(memcpyRc != EOK){
@@ -255954,6 +256037,10 @@ void* sqlite3Codec(void *ctx, void *data, Pgno pgno, int mode){
       return pData;
       break;
     case 6:
+      if (pCtx->writeCtx == NULL) {
+        return pData;
+      }
+      cipherPageSize = pCtx->writeCtx->codecConst.cipherPageSize;
       if(pgno == 1){
         memcpyRc = memcpy_s(pCtx->buffer, cipherPageSize, pCtx->salt, FILE_HEADER_SIZE);
         if(memcpyRc != EOK){
@@ -255969,6 +256056,10 @@ void* sqlite3Codec(void *ctx, void *data, Pgno pgno, int mode){
       return pCtx->buffer;
       break;
     case 7:
+      if (pCtx->writeCtx == NULL) {
+        return pData;
+      }
+      cipherPageSize = pCtx->writeCtx->codecConst.cipherPageSize;
       if(pgno == 1){
         memcpyRc = memcpy_s(pCtx->buffer, cipherPageSize, pCtx->salt, FILE_HEADER_SIZE);
         if(memcpyRc != EOK){
@@ -255999,62 +256090,87 @@ void sqlite3CodecDetach(void *ctx){
 }
 
 #if SQLITE_OS_UNIX
+#include <sys/file.h>
+//return lock succ, lock busy, file not exist, only use in rekey pageSize
+int CodecRekeyTryFileLock(int fd, u8 lockType)
+{
+  int rc;
+  do {
+    rc = flock(fd, lockType != LOCK_UN ? (lockType | LOCK_NB) : LOCK_UN);
+  } while(rc<0 && errno==EINTR);
+  if (rc == 0) {
+    return SQLITE_OK;
+  }
+  return (errno == EWOULDBLOCK) ? SQLITE_BUSY : SQLITE_IOERR;
+}
+
+// return unlock succ, lock busy, file not exist
+int CodecRekeyFileUnlock(int fd)
+{
+  return CodecRekeyTryFileLock(fd, LOCK_UN);
+}
+
+int CodecRekeyTryFileLockTimeout(int fd, u8 exLock, sqlite3_int64 timeoutMs)
+{
+  sqlite3_int64 endTimeMs = 0;
+  sqlite3_int64 curTimeMs = 0;
+  // unixCurrentTimeInt64 always return OK
+  (void)unixCurrentTimeInt64(0, &curTimeMs);
+  endTimeMs = curTimeMs + timeoutMs;
+  int rc = CodecRekeyTryFileLock(fd, exLock);
+  while(rc == SQLITE_BUSY && endTimeMs > curTimeMs) {
+    (void)unixCurrentTimeInt64(0, &curTimeMs);
+    usleep(100);
+    rc = CodecRekeyTryFileLock(fd, exLock);
+  }
+  return rc;
+}
+
 static int CodecFileLock(Pager *pPager, short lockType)
 {
-  sqlite3_file *fd = pPager->fd;
-  unixFile *pFile = (unixFile *)fd;
+  u8 checkFileId = Sqlite3GetCheckFileId(pPager->pVfs);
+  if (checkFileId == 0) {
+    return SQLITE_OK;
+  }
+  if (!isOpen(pPager->fd)) {
+    return SQLITE_OK;
+  }
+  unixFile *pFile = Sqlite3GetUnixFile(pPager->fd, checkFileId);
   unixInodeInfo *pInode = pFile->pInode;
   if (pInode == NULL) {
     sqlite3_log(SQLITE_IOERR_RDLOCK, "Codec file lock %d go wrong", lockType);
     return SQLITE_IOERR_RDLOCK;
   }
   sqlite3_mutex_enter(pInode->pLockMutex);
-  // last conntection release the lock
-  if (lockType == F_UNLCK && pInode->nRef > 1) {
-    sqlite3_mutex_leave(pInode->pLockMutex);
-    return SQLITE_OK;
-  }
-  if (lockType == F_WRLCK && pInode->nRef > 1) {
-    sqlite3_mutex_leave(pInode->pLockMutex);
-    sqlite3_log(SQLITE_BUSY, "Codec file lock wrlock busy ref %d", pInode->nRef);
-    return SQLITE_BUSY;
-  }
-  if (lockType == F_RDLCK && pInode->codecPager != 0 && pInode->codecPager != pPager) {
-    sqlite3_mutex_leave(pInode->pLockMutex);
-    sqlite3_log(SQLITE_BUSY, "Codec exists file lock wrlock");
-    return SQLITE_BUSY;
-  }
-  struct flock lock;
-  lock.l_whence = SEEK_SET;
-  lock.l_start = SHARED_CODEC_BYTE;
-  lock.l_len = 1;
-  // F_RDLCK, F_WRLCK, F_UNLCK
-  lock.l_type = lockType;
-  int rc = osSetPosixAdvisoryLock(pFile->h, &lock, pFile);
-  if (rc < 0) {
-    int tErrno = errno;
-    rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_RDLOCK);
-    if (IS_LOCK_ERROR(rc)) {
-      storeLastErrno(pFile, tErrno);
-    }
-    sqlite3_log(rc, "Codec file lock %d: errno = %d", lockType, tErrno);
+  int rc;
+  if (lockType == F_UNLCK) {
+    rc = CodecRekeyFileUnlock(pFile->h);
   } else {
-    pInode->codecPager = (lockType == F_WRLCK ? pPager : 0);
+    rc = CodecRekeyTryFileLock(pFile->h, lockType == F_WRLCK ? LOCK_EX : LOCK_SH);
   }
   sqlite3_mutex_leave(pInode->pLockMutex);
   return rc;
 }
 #endif
 
-int sqlite3CodecAttach(sqlite3* db, int nDb, const void *pKey, int nKey){
-  if(db == NULL){
-    return SQLITE_ERROR;
-  }
-  Btree *p = db->aDb[nDb].pBt;
-  if(p == NULL || pKey == NULL || nKey <= 0){
-    return SQLITE_OK;
+void sqlite3CodecSetCtx(Btree *p, CodecContext *ctx)
+{
+  if (ctx == NULL) {
+    p->pBt->btsFlags &= ~BTS_PAGESIZE_FIXED;
+    sqlite3PagerClearCodec(p->pBt->pPager);
+    p->db->nextPagesize = 0;
+    return;
   }
-  opensslActive();
+  sqlite3PagerSetCodec(sqlite3BtreePager(p), sqlite3Codec, NULL, sqlite3CodecDetach, (void *)ctx);
+  p->pBt->btsFlags &= ~BTS_PAGESIZE_FIXED;
+  p->db->nextPagesize = ctx->readCtx->codecConst.cipherPageSize;
+  sqlite3BtreeSetPageSize(p, ctx->readCtx->codecConst.cipherPageSize, ctx->readCtx->codecConst.reserveSize, 0);
+  //p->pBt->btsFlags |= BTS_PAGESIZE_FIXED;
+  sqlite3BtreeSecureDelete(p, 1);
+}
+
+int sqlite3CodecInitCtx(Btree *p, const void *pKey, int nKey, CodecParameter *parm)
+{
   CodecContext *ctx = (CodecContext *)sqlite3Malloc(sizeof(CodecContext));
   if(ctx == NULL){
     return SQLITE_NOMEM;
@@ -256064,42 +256180,51 @@ int sqlite3CodecAttach(sqlite3* db, int nDb, const void *pKey, int nKey){
     sqlite3_free(ctx);
     return SQLITE_ERROR;
   }
-  sqlite3_mutex_enter(db->mutex);
-  Pager *pPager = p->pBt->pPager;
-#if SQLITE_OS_UNIX
-  if (pPager->fd != NULL && isOpen(pPager->fd)) {
-    int ret = CodecFileLock(pPager, F_RDLCK);
-    if(ret != SQLITE_OK){
-      sqlite3_free(ctx);
-      sqlite3_mutex_leave(db->mutex);
-      sqlite3_log(ret, "sqlite3CodecAttach: codec lock error");
-      return ret;
-    }
-  }
-#endif
-#ifdef SQLITE_CODEC_ATTACH_CHANGED
-  int rc = sqlite3CodecInitContext(ctx, p, pKey, nKey, nDb);
-#else
-  int rc = sqlite3CodecInitContext(ctx, p, pKey, nKey);
-#endif /* SQLITE_CODEC_ATTACH_CHANGED */
+  opensslActive();
+  int rc = sqlite3CodecInitContext(ctx, p, pKey, nKey, parm);
   if(rc != SQLITE_OK){
     sqlite3_free(ctx);
-    sqlite3_mutex_leave(db->mutex);
     return rc;
   }
-  sqlite3PagerSetCodec(sqlite3BtreePager(p), sqlite3Codec, NULL, sqlite3CodecDetach, (void *)ctx);
-
-  db->nextPagesize = ctx->readCtx->codecConst.cipherPageSize;
-  p->pBt->btsFlags &= ~BTS_PAGESIZE_FIXED;
-  sqlite3BtreeSetPageSize(p, ctx->readCtx->codecConst.cipherPageSize, ctx->readCtx->codecConst.reserveSize, 0);
-  sqlite3BtreeSecureDelete(p, 1);
-  if(isOpen(pPager->fd)){
+  sqlite3_file *fd = p->pBt->pPager->fd;
+  if(isOpen(p->pBt->pPager->fd)){
     sqlite3BtreeSetAutoVacuum(p, SQLITE_DEFAULT_AUTOVACUUM);
   }
+  if(fd == NULL || !(isOpen(fd)) || sqlite3OsRead(fd, ctx->salt, SALT_SIZE, 0) != SQLITE_OK){
+    Buffer salt;
+    salt.buffer = ctx->salt;
+    salt.bufferSize = SALT_SIZE;
+    rc = opensslGetRandom(&salt);
+    if(rc != SQLITE_OK){
+      sqlite3CodecFreeContext(ctx);
+      sqlite3_free(ctx);
+      sqlite3_log(rc, "codec generate salt failed");
+      return rc;
+    }
+  }
+  sqlite3CodecSetCtx(p, ctx);
+  return SQLITE_OK;
+}
 
+int sqlite3CodecAttach(sqlite3* db, int nDb, const void *pKey, int nKey)
+{
+  if(db == NULL){
+    return SQLITE_ERROR;
+  }
+  Btree *p = db->aDb[nDb].pBt;
+  if(p == NULL || pKey == NULL || nKey <= 0){
+    return SQLITE_OK;
+  }
+  sqlite3_mutex_enter(db->mutex);
+  CodecParameter *parm = sqlite3CodecGetDedaultParameters();
+#ifdef SQLITE_CODEC_ATTACH_CHANGED
+  if (nDb > 1) {
+    parm = &db->codecParm[0];
+  }
+#endif
+  int rc = sqlite3CodecInitCtx(p, pKey, nKey, parm);
   sqlite3_mutex_leave(db->mutex);
-
-  return SQLITE_OK;
+  return rc;
 }
 
 void sqlite3CodecGetKey(sqlite3* db, int nDb, void **pKey, int *nKey)
@@ -256140,6 +256265,451 @@ int sqlite3_rekey(sqlite3 *db, const void *pKey, int nKey){
   return sqlite3_rekey_v2(db, "main", pKey, nKey);
 }
 
+#define REKEY_RENAME_SUFFIX "-rekey-rename"
+#define REKEY_EXPORT_SUFFIX "-rekey-export"
+#define REKEY_LOCK_SUFFIX "-rekey-lock"
+#if SQLITE_OS_UNIX
+CODEC_STATIC int SQLite3UnixFileExists(const char *file)
+{
+  struct stat buf;
+  return osStat(file, &buf) == 0 ;
+}
+
+CODEC_STATIC char *GetRekeyRenamePath(const char *dbPath)
+{
+  return sqlite3_mprintf("%s" REKEY_RENAME_SUFFIX, dbPath);
+}
+
+CODEC_STATIC char *GetRekeyExportPath(const char *dbPath)
+{
+  return sqlite3_mprintf("%s" REKEY_EXPORT_SUFFIX, dbPath);
+}
+
+CODEC_STATIC char *GetRekeyLockPath(const char *dbPath)
+{
+  return sqlite3_mprintf("%s" REKEY_LOCK_SUFFIX, dbPath);
+}
+
+// return lock succ, lock busy, file not exist
+CODEC_STATIC int CodecRecoverRekeyFiles(const char *dbPath)
+{
+  int rc = SQLITE_OK;
+  char *exportPath = GetRekeyExportPath(dbPath);
+  if (exportPath == NULL) {
+    return SQLITE_NOMEM_BKPT;
+  }
+  if (SQLite3UnixFileExists(exportPath)) {
+    (void)unlink(exportPath);
+  }
+  sqlite3_free(exportPath);
+  // means restore file has been rename
+  if (SQLite3UnixFileExists(dbPath)) {
+    return SQLITE_OK;
+  }
+  char *renamePath = GetRekeyRenamePath(dbPath);
+  if (renamePath == NULL) {
+    return SQLITE_NOMEM_BKPT;
+  }
+  if (SQLite3UnixFileExists(renamePath)) {
+    rc = rename(renamePath, dbPath);
+    // unlink failed, report error
+    if (rc != 0) {
+      sqlite3_log(SQLITE_IOERR, "Rekey rename db failed sysno %d", errno);
+      return SQLITE_IOERR;
+    }
+  }
+  return SQLITE_OK;
+}
+
+CODEC_STATIC int CodecRekeyRenameDb(const char *dbPath)
+{
+  // checkpoint db before, so only rename db file
+  char *renamePath = GetRekeyRenamePath(dbPath);
+  if (renamePath == NULL) {
+    return SQLITE_NOMEM_BKPT;
+  }
+  int rc = rename(dbPath, renamePath);
+  if (rc != 0) {
+    sqlite3_log(SQLITE_IOERR, "Rekey rename to renamePath failed sysno %d", errno);
+    rc = SQLITE_IOERR;
+    goto rename_finished;
+  }
+  char *exportPath = GetRekeyExportPath(dbPath);
+  if (exportPath == NULL) {
+    rc = SQLITE_NOMEM_BKPT;
+    goto rename_finished;
+  }
+  rc = rename(exportPath, dbPath);
+  sqlite3_free(exportPath);
+  if (rc != 0) {
+    sqlite3_log(SQLITE_IOERR, "Rekey rename export db failed sysno %d", errno);
+    rc = SQLITE_IOERR;
+  } else {
+    (void)unlink(renamePath);
+  }
+rename_finished:
+  sqlite3_free(renamePath);
+  return rc;
+}
+
+CODEC_STATIC int CodecCheckRecoverRekey(const char *dbPath)
+{
+  char *rekeyLockPath = GetRekeyLockPath(dbPath);
+  if (rekeyLockPath == NULL) {
+    return SQLITE_NOMEM_BKPT;
+  }
+  // file not exist, not need recover
+  if (!SQLite3UnixFileExists(rekeyLockPath)) {
+    sqlite3_free(rekeyLockPath);
+    return SQLITE_OK;
+  }
+  int lockFd = robust_open(rekeyLockPath, O_RDWR|O_NOFOLLOW, 0);
+  if (lockFd <= 0) {
+    sqlite3_free(rekeyLockPath);
+    if (errno == ENOENT) {
+      sqlite3_log(SQLITE_WARNING_DUMP, "sqlite rekey file may recover, do nothing");
+      return SQLITE_OK;
+    } else if (errno == EACCES) {
+      // try rename file when miss permission
+      return CodecRecoverRekeyFiles(dbPath);
+    }
+    return unixLogError(SQLITE_CANTOPEN_BKPT, "[rekey]openRekeyFile", dbPath);
+  }
+  // 300ms timeout
+  int rc = CodecRekeyTryFileLockTimeout(lockFd, LOCK_EX, 300);
+  if (rc != SQLITE_OK) {
+    // can't get lock, means other hold lock, just return SQLITE_BUSY
+    sqlite3_free(rekeyLockPath);
+    osClose(lockFd);
+    sqlite3_log(rc, "sqlite check recover rekey failed");
+    return SQLITE_BUSY;
+  }
+  rc = CodecRecoverRekeyFiles(dbPath);
+  if (rc != SQLITE_OK) {
+    sqlite3_log(rc, "Clear rekey file failed");
+    goto recovery_finish;
+  }
+
+  (void)osUnlink(rekeyLockPath);
+recovery_finish:
+  sqlite3_free(rekeyLockPath);
+  CodecRekeyFileUnlock(lockFd);
+  osClose(lockFd);
+  return rc;
+}
+#endif
+
+CODEC_STATIC int CodecRekeyInitCodecCtx(Btree *p, const void *pKey, int nKey, CodecContext **oldCtx)
+{
+  *oldCtx = NULL;
+  CodecContext *ctx = (CodecContext *)p->pBt->pPager->pCodec;
+  if (pKey == NULL || nKey == 0) {
+    if (ctx != NULL) {
+      sqlite3CodecFreeKeyContext(ctx->writeCtx);
+      sqlite3_free(ctx->writeCtx);
+      ctx->writeCtx = NULL;
+    }
+    return SQLITE_OK;
+  }
+  SWAP(CodecContext *, *oldCtx, p->pBt->pPager->pCodec);
+  sqlite3CodecSetCtx(p, NULL);
+  // 1 use rekey param
+  CodecParameter *parm = &p->db->codecParm[1];
+  int rc = sqlite3CodecInitCtx(p, pKey, nKey, parm);
+  if (rc != SQLITE_OK) {
+    sqlite3CodecSetCtx(p, *oldCtx);
+    return rc;
+  }
+  CodecContext *curCtx = (CodecContext *)(p->pBt->pPager->pCodec);
+  if (*oldCtx != NULL) {
+    SWAP(KeyContext *, (*oldCtx)->readCtx, curCtx->readCtx);
+    // use same salt with old ctx
+    (void)memcpy(ctx->salt, (*oldCtx)->salt, SALT_SIZE);
+  } else {
+    sqlite3CodecFreeKeyContext(curCtx->readCtx);
+    sqlite3_free(curCtx->readCtx);
+    curCtx->readCtx = NULL;
+  }
+  return rc;
+}
+
+CODEC_STATIC int CodecRekeyAttachNewDb(sqlite3 *db, const char *srcDbPath, const void *pKey, int nKey)
+{
+  char *attachSql = NULL;
+  int rc = SQLITE_OK;
+  if (pKey == NULL || pKey <= 0) {
+    attachSql = sqlite3_mprintf("ATTACH DATABASE '%s%s' AS rekeyDb;", srcDbPath, REKEY_EXPORT_SUFFIX);
+    if (attachSql == NULL) {
+      return SQLITE_NOMEM_BKPT;
+    }
+    rc = sqlite3_exec(db, attachSql, 0, 0, NULL);
+    sqlite3_free(attachSql);
+    return rc;
+  }
+  sqlite3_stmt *stmt = NULL;
+  attachSql = sqlite3_mprintf("ATTACH DATABASE '%s%s' AS rekeyDb KEY ?;", srcDbPath, REKEY_EXPORT_SUFFIX);
+  if (attachSql == NULL) {
+    return SQLITE_NOMEM_BKPT;
+  }
+  rc = sqlite3_prepare_v2(db, attachSql, -1, &stmt, NULL);
+  sqlite3_free(attachSql);
+  if (rc != SQLITE_OK) {
+    sqlite3_log(rc, "[rekey]Attach new db failed on prepare %d", rc);
+    return rc;
+  }
+  rc = sqlite3_bind_blob(stmt, 1, pKey, nKey, SQLITE_STATIC);
+  if (rc != SQLITE_OK) {
+    (void)sqlite3_finalize(stmt);
+    sqlite3_log(rc, "[rekey]Attach new db failed on bind %d", rc);
+    return rc;
+  }
+  rc = sqlite3_step(stmt);
+  (void)sqlite3_finalize(stmt);
+  if (rc != SQLITE_ROW && rc != SQLITE_DONE) {
+    sqlite3_log(rc, "[rekey]Attach new db failed on step %d", rc);
+  } else {
+    rc = SQLITE_OK;
+  }
+  return rc;
+}
+
+CODEC_STATIC int CodecRekeyExportNewDb(sqlite3 *db, const char *srcDbPath, const void *pKey, int nKey)
+{
+  memcpy(&db->codecParm[0], &db->codecParm[1], sizeof(CodecParameter));
+  int rc = CodecRekeyAttachNewDb(db, srcDbPath, pKey, nKey);
+  if (rc != SQLITE_OK) {
+    sqlite3_log(rc, "Attach rekey db failed %d", rc);
+    return rc;
+  }
+  rc = sqlite3_exec(db, "PRAGMA rekeyDb.journal_mode=OFF", 0, 0, NULL);
+  if (rc != SQLITE_OK) {
+    sqlite3_log(rc, "Attach rekey db set journal mode failed %d", rc);
+    goto EXPORT_OUT;
+  }
+  rc = sqlite3_exec(db, "SELECT export_database('rekeyDb')", 0, 0, NULL);
+  if (rc != SQLITE_OK) {
+    sqlite3_log(rc, "Attach rekey db export db failed %d", rc);
+    goto EXPORT_OUT;
+  }
+EXPORT_OUT:
+  (void)sqlite3_exec(db, "DETACH DATABASE rekeyDb;", 0, 0, NULL);
+  return rc;
+}
+
+#if SQLITE_OS_UNIX
+CODEC_STATIC int CodecRekeyByExport(sqlite3 *db, int dbIdx, const void *pKey, int nKey)
+{
+  Btree *p = db->aDb[dbIdx].pBt;
+  int rc;
+  Pager *pPager = p->pBt->pPager;
+  const char *dbFileName = sqlite3BtreeGetFilename(p);
+  char *dbPath = sqlite3_mprintf("%s", dbFileName);
+  if (dbPath == NULL) {
+    return SQLITE_NOMEM_BKPT;
+  }
+  int lockFd = 0;
+  char *lockPath = NULL;
+  sqlite3_mutex_enter(db->mutex);
+  // step 1: Codec file acquire exclusive lock
+  if((rc = CodecFileLock(pPager, F_WRLCK)) != SQLITE_OK){
+    sqlite3_log(rc, "sqlite3 rekey export lock error.");
+    goto rekey_finish2;
+  }
+  // step 2: open lock file for rename export db
+  lockPath = GetRekeyLockPath(dbPath);
+  if (lockPath == NULL) {
+    (void)CodecFileLock(pPager, F_RDLCK);
+    rc = SQLITE_NOMEM_BKPT;
+    goto rekey_finish2;
+  }
+  lockFd = robust_open(lockPath, O_RDWR|O_CREAT|O_NOFOLLOW, 0);
+  if (lockFd <= 0) {
+    sqlite3_log(rc, "sqlite3 rekey open lock file error sysno %d.", errno);
+    rc = SQLITE_CANTOPEN_BKPT;
+    goto rekey_finish2;
+  }
+  // step 3: acquire exclusive lock for rename db
+  rc = CodecRekeyTryFileLock(lockFd, LOCK_EX);
+  if (rc != SQLITE_OK) {
+    sqlite3_log(rc, "sqlite rekey try file lock go wrong %d sysno %d", rc, errno);
+    goto rekey_finish1;
+  }
+  // step 4: detect if have other connection
+  if (!IsOnlyOneConnection(pPager)) {
+    sqlite3_log(rc, "sqlite rekey have other conntions");
+    rc = SQLITE_BUSY;
+    goto rekey_finish1;
+  }
+  // step 5: export db
+  rc = CodecRekeyExportNewDb(db, dbPath, pKey, nKey);
+  if (rc != SQLITE_OK) {
+    sqlite3_log(rc, "sqlite rekey export db go wrong %d", rc);
+    goto rekey_finish1;
+  }
+  (void)CodecFileLock(pPager, F_RDLCK);
+  sqlite3_mutex_leave(db->mutex);
+  // step 6: close db and rename
+  sqlite3_close_v2(db);
+  db = NULL;
+  rc = CodecRekeyRenameDb(dbPath);
+  if (rc != SQLITE_OK) {
+    sqlite3_log(rc, "sqlite export db go wrong %d sysno %d", rc, errno);
+  }
+rekey_finish1:
+  // step 7: clear
+  (void)CodecRecoverRekeyFiles(dbPath);
+  CodecRekeyFileUnlock(lockFd);
+rekey_finish2:
+  if (db != NULL) {
+    (void)CodecFileLock(pPager, F_RDLCK);
+    sqlite3_mutex_leave(db->mutex);
+    sqlite3_close_v2(db);
+  }
+  if (lockPath != NULL) {
+    (void)unlink(lockPath);
+    sqlite3_free(lockPath);
+  }
+  if (dbPath != NULL) {
+    sqlite3_free(dbPath);
+  }
+  if (lockFd > 0) {
+    osClose(lockFd);
+  }
+  return rc;
+}
+#endif
+
+CODEC_STATIC int CodecRekeyWriteDirectly(sqlite3 *db, int dbIdx, const void *pKey, int nKey)
+{
+  Btree *p = db->aDb[dbIdx].pBt;
+  if(p == NULL){
+    return SQLITE_OK;
+  }
+  int pageCount;
+  Pgno pgno;
+  PgHdr *page = NULL;
+  Pager *pPager = p->pBt->pPager;
+  sqlite3_mutex_enter(db->mutex);
+
+  CodecContext *oldCtx = NULL;
+  int rc = CodecRekeyInitCodecCtx(p, pKey, nKey, &oldCtx);
+  if (rc != SQLITE_OK) {
+    sqlite3_mutex_leave(db->mutex);
+    return rc;
+  }
+#if SQLITE_OS_UNIX
+  if((rc = CodecFileLock(pPager, F_WRLCK)) != SQLITE_OK){
+    sqlite3CodecSetCtx(p, oldCtx);
+    sqlite3_mutex_leave(db->mutex);
+    sqlite3_log(rc, "sqlite3 rekey: error when lock.");
+    return rc;
+  }
+#endif
+  rc = sqlite3BtreeBeginTrans(p, 1, 0);
+  if(rc != SQLITE_OK){
+    sqlite3CodecSetCtx(p, oldCtx);
+    sqlite3_log(rc, "sqlite3 rekey: error when begin trans.");
+    goto rekey_write_finished;
+  }
+  sqlite3PagerPagecount(pPager, &pageCount);
+  for(pgno = 1; pgno <= (unsigned int)pageCount; pgno++){
+    if(PAGER_SJ_PGNO(pPager) != pgno){
+      rc = sqlite3PagerGet(pPager, pgno, &page, 0);
+      if(rc == SQLITE_OK){
+        rc = sqlite3PagerWrite(page);
+        if(rc == SQLITE_OK){
+          sqlite3PagerUnref(page);
+        }else{
+          sqlite3_log(SQLITE_WARNING, "sqlite3 rekey: error when writing page %d: errno = %d.", pgno, rc);
+        }
+      }else{
+        sqlite3_log(SQLITE_WARNING, "sqlite3 rekey: error when reading page %d: errno = %d.", pgno, rc);
+      }
+    }
+  }
+  if(rc == SQLITE_OK){
+    (void)sqlite3BtreeCommit(p);
+    CodecContext *ctx = (CodecContext *)(p->pBt->pPager->pCodec);
+    // encrypt db to unencrypt db, readCtx != NULL && writeCtx = NULL
+    if(ctx != NULL && ctx->writeCtx == NULL){
+      sqlite3CodecDetach(ctx);
+      p->pBt->pPager->pCodec = NULL;
+      ctx = NULL;
+    }
+    // unencrypt/encrypt db to encrypt db, writeCtx != NULL
+    if(ctx != NULL && ctx->writeCtx != NULL){
+      sqlite3CodecFreeKeyContext(ctx->readCtx);
+      if (ctx->readCtx == NULL) {
+        ctx->readCtx = (KeyContext *)sqlite3Malloc(sizeof(KeyContext));
+      }
+      (void)sqlite3CodecCopyKeyContext(ctx->writeCtx, ctx->readCtx);
+    }
+    sqlite3CodecDetach(oldCtx);
+  }else{
+    sqlite3CodecSetCtx(p, oldCtx);
+    (void)sqlite3BtreeRollback(p, SQLITE_ABORT_ROLLBACK, 0);
+  }
+
+rekey_write_finished:
+#if SQLITE_OS_UNIX
+  (void)CodecFileLock(pPager, F_RDLCK);
+#endif
+  sqlite3_mutex_leave(db->mutex);
+  return rc;
+}
+
+CODEC_STATIC int sqlite3CodecGetHmacReserveSize(CodecParameter *param){
+  int hmacSize = GetHmacSize(param->hmacAlgo);
+  int cipherBlockSize = opensslGetBlockSize(opensslGetCipher(sqlite3CodecGetDefaultAttachCipher(param)));
+  int blockSize = cipherBlockSize;
+  while(blockSize < MIN_BLOCK_SIZE){
+    blockSize += cipherBlockSize;
+  }
+  int reserveSize = MAX_INIT_VECTOR_SIZE + hmacSize;
+  if(reserveSize % blockSize != 0){
+    reserveSize = (reserveSize / blockSize + 1) * blockSize;
+  }
+  return reserveSize;
+}
+
+CODEC_STATIC int sqlite3_rekey_v3_inner(sqlite3 *db, const char *zDb, const void *pKey, int nKey)
+{
+  int rc = SQLITE_OK;
+  int iDb = sqlite3CodecGetDbIndex(db, zDb);
+  Btree *p = db->aDb[iDb].pBt;
+  if (p == NULL) {
+    return SQLITE_OK;
+  }
+  Pager *pPager = p->pBt->pPager;
+  if (Sqlite3GetCheckFileId(pPager->pVfs) == 0) {
+    sqlite3_log(SQLITE_MISUSE, "[rekey]Not support fs type");
+    return SQLITE_MISUSE;
+  }
+  sqlite3_log(SQLITE_WARNING_DUMP, "[rekey]start...");
+  CodecParameter *rekeyParm = &db->codecParm[1];
+  sqlite3_mutex_enter(db->mutex);
+  int curReserveSize = sqlite3BtreeGetRequestedReserve(p);
+  sqlite3_mutex_leave(db->mutex);
+  if (pKey == NULL || nKey == 0) {
+    rekeyParm->reserveSize = curReserveSize;
+  } else {
+    rekeyParm->reserveSize = sqlite3CodecGetHmacReserveSize(rekeyParm);
+  }
+  if (rekeyParm->pageSize != sqlite3BtreeGetPageSize(p) ||
+    rekeyParm->reserveSize != curReserveSize) {
+#if SQLITE_OS_UNIX
+    sqlite3_log(SQLITE_WARNING_DUMP, "[rekey]export pagesz-resverdSz %d-%d --> %d-%d",
+      sqlite3BtreeGetPageSize(p), curReserveSize, rekeyParm->pageSize, rekeyParm->reserveSize);
+    rc = CodecRekeyByExport(db, iDb, pKey, nKey);
+#endif
+  } else {
+    rc = CodecRekeyWriteDirectly(db, iDb, pKey, nKey);
+    (void)sqlite3Close(db, 1);
+  }
+  sqlite3_log(rc, "[rekey]end...");
+  return rc;
+}
+
 int sqlite3_rekey_v2(sqlite3 *db, const char *zDb, const void *pKey, int nKey){
   if(db == NULL || pKey == NULL || nKey == 0){
     return SQLITE_ERROR;
@@ -256164,26 +256734,30 @@ int sqlite3_rekey_v2(sqlite3 *db, const char *zDb, const void *pKey, int nKey){
     return rc;
   }
   sqlite3_mutex_enter(db->mutex);
-  rc = sqlite3BtreeBeginTrans(p, 1, 0);
-  if(rc != SQLITE_OK){
-    sqlite3_mutex_leave(db->mutex);
-    sqlite3_log(rc, "sqlite3 rekey: error when begin trans %s.", sqlite3PagerFilename(pPager, 1));
-    return rc;
-  }
 #if SQLITE_OS_UNIX
   if((rc = CodecFileLock(pPager, F_WRLCK)) != SQLITE_OK){
-    (void)sqlite3BtreeRollback(p, SQLITE_ABORT_ROLLBACK, 0);
     sqlite3_mutex_leave(db->mutex);
     sqlite3_log(rc, "sqlite3_rekey_v2: error when lock %s.", sqlite3PagerFilename(pPager, 1));
     return rc;
   }
 #endif
+  rc = sqlite3BtreeBeginTrans(p, 1, 0);
+  if(rc != SQLITE_OK){
+#if SQLITE_OS_UNIX
+    (void)CodecFileLock(pPager, F_RDLCK);
+#endif
+    sqlite3_mutex_leave(db->mutex);
+    sqlite3_log(rc, "sqlite3 rekey: error when begin trans %s.", sqlite3PagerFilename(pPager, 1));
+    return rc;
+  }
+
   sqlite3PagerPagecount(pPager, &pageCount);
   // support hmac algo changed by using rekey operation
+  CodecParameter *rekeyParm = &db->codecParm[1];
   int oldHmacAlgo = ctx->writeCtx->codecConst.hmacAlgo;
-  if( ctx->writeCtx->codecConst.rekeyHmacAlgo!=ctx->writeCtx->codecConst.hmacAlgo ){
-    sqlite3CodecSetHmacAlgorithm(ctx->writeCtx, ctx->writeCtx->codecConst.rekeyHmacAlgo);
-    sqlite3CodecSetKdfAlgorithm(ctx->writeCtx, ctx->writeCtx->codecConst.rekeyHmacAlgo);
+  if( oldHmacAlgo!=rekeyParm->hmacAlgo ){
+    sqlite3CodecSetHmacAlgorithm(ctx->writeCtx, rekeyParm->hmacAlgo);
+    sqlite3CodecSetKdfAlgorithm(ctx->writeCtx, rekeyParm->hmacAlgo);
   }
 
   for(pgno = 1; pgno <= (unsigned int)pageCount; pgno++){
@@ -256206,7 +256780,7 @@ int sqlite3_rekey_v2(sqlite3 *db, const char *zDb, const void *pKey, int nKey){
     sqlite3CodecFreeKeyContext(ctx->readCtx);
     (void)sqlite3CodecCopyKeyContext(ctx->writeCtx, ctx->readCtx);
   }else{
-    if( ctx->writeCtx->codecConst.rekeyHmacAlgo!=oldHmacAlgo ){
+    if( rekeyParm->hmacAlgo!=oldHmacAlgo ){
       sqlite3CodecSetHmacAlgorithm(ctx->writeCtx, oldHmacAlgo);
       sqlite3CodecSetKdfAlgorithm(ctx->writeCtx, oldHmacAlgo);
     }
@@ -256216,9 +256790,133 @@ int sqlite3_rekey_v2(sqlite3 *db, const char *zDb, const void *pKey, int nKey){
   (void)CodecFileLock(pPager, F_RDLCK);
 #endif
   sqlite3_mutex_leave(db->mutex);
+
   return rc;
 }
 
+typedef struct {
+  // aes-256-gcm, aes-256-cbc
+  const char *pCipher;
+  // SHA1, SHA256, SHA512
+  const char *pHmacAlgo;
+  // KDF_SHA1, KDF_SHA256, KDF_SHA512
+  const char *pKdfAlgo;
+  const char *pKey;
+  int nKey;
+  int kdfIter;
+  int pageSize;
+} CodecConfig;
+
+typedef struct {
+  const char *dbPath;
+  CodecConfig dbCfg;
+  CodecConfig rekeyCfg;
+} CodecRekeyConfig;
+
+static char *GenerateSQLFromCodeConfig(CodecConfig *config, u8 isKeyCfg)
+{
+  if (config->pKey == NULL || config->nKey == 0) {
+    return isKeyCfg ? NULL : sqlite3_mprintf("PRAGMA codec_rekey_page_size=%d;", config->pageSize);
+  }
+  if (isKeyCfg) {
+    return sqlite3_mprintf("PRAGMA codec_cipher=%Q;PRAGMA codec_hmac_algo=%Q;PRAGMA codec_kdf_algo=%Q;PRAGMA codec_page_size=%d;PRAGMA codec_kdf_iter=%d;",
+      config->pCipher, config->pHmacAlgo, config->pKdfAlgo, config->pageSize, config->kdfIter);
+  }
+  return sqlite3_mprintf("PRAGMA codec_rekey_cipher=%Q;PRAGMA codec_rekey_hmac_algo=%Q;PRAGMA codec_rekey_kdf_algo=%Q;PRAGMA codec_rekey_page_size=%d;"
+    "PRAGMA codec_rekey_kdf_iter=%d;", config->pCipher, config->pHmacAlgo, config->pKdfAlgo, config->pageSize, config->kdfIter);
+}
+
+CODEC_STATIC int CheckCodecRekeyConfig(CodecRekeyConfig *rekeyConfig)
+{
+  if (rekeyConfig == NULL) {
+    sqlite3_log(SQLITE_ERROR, "[rekey]invalid argument");
+    return SQLITE_ERROR;
+  }
+  if (rekeyConfig->dbPath == NULL || strlen(rekeyConfig->dbPath) + sizeof(REKEY_EXPORT_SUFFIX) > FILENAME_MAX) {
+    sqlite3_log(SQLITE_ERROR, "[rekey]rekey invalid path or path too long");
+    return SQLITE_ERROR;
+  }
+  if (rekeyConfig->dbCfg.pKey != NULL && rekeyConfig->dbCfg.nKey < 0) {
+    sqlite3_log(SQLITE_ERROR, "[rekey]rekey invalid db key length %d", rekeyConfig->dbCfg.nKey);
+    return SQLITE_ERROR;
+  }
+  if (rekeyConfig->rekeyCfg.pKey != NULL && rekeyConfig->rekeyCfg.nKey < 0) {
+    sqlite3_log(SQLITE_ERROR, "[rekey]rekey invalid rekey length %d", rekeyConfig->rekeyCfg.nKey);
+    return SQLITE_ERROR;
+  }
+  return SQLITE_OK;
+}
+
+CODEC_STATIC int RekeyPrepare(CodecRekeyConfig *rekeyConfig, sqlite3 **rekeyDb)
+{
+  int rc = CheckCodecRekeyConfig(rekeyConfig);
+  if (rc != SQLITE_OK) {
+    return rc;
+  }
+#if SQLITE_OS_UNIX
+  if (!SQLite3UnixFileExists(rekeyConfig->dbPath)) {
+    sqlite3_log(SQLITE_ERROR, "[rekey]rekey file not exist");
+    return SQLITE_ERROR;
+  }
+#endif
+  sqlite3 *db = NULL;
+  rc = sqlite3_open_v2(rekeyConfig->dbPath, &db, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_FULLMUTEX, NULL);
+  if (rc != SQLITE_OK) {
+    sqlite3_log(rc, "[rekey]Failed to open main database");
+    goto cleanup;
+  }
+  if (rekeyConfig->dbCfg.pKey != NULL && rekeyConfig->dbCfg.nKey != 0) {
+    rc = sqlite3_key(db, rekeyConfig->dbCfg.pKey, rekeyConfig->dbCfg.nKey);
+    if (rc != SQLITE_OK) {
+      sqlite3_log(rc, "[rekey]key failed: %d", rc);
+      goto cleanup;
+    }
+  }
+  char *codecSql = GenerateSQLFromCodeConfig(&rekeyConfig->dbCfg, 1);
+  if (codecSql != NULL) {
+    rc = sqlite3_exec(db, codecSql, NULL, NULL, NULL);
+    sqlite3_free(codecSql);
+    if (rc != SQLITE_OK) {
+      sqlite3_log(rc, "[rekey]PRAGMA db cfg failed: %d", rc);
+      goto cleanup;
+    }
+  }
+  rc = sqlite3_exec(db, "PRAGMA journal_mode=WAL;", NULL, NULL, NULL);
+  if (rc != SQLITE_OK) {
+    sqlite3_log(rc, "[rekey]PRAGMA wal failed: %d", rc);
+    goto cleanup;
+  }
+  rc = sqlite3_wal_checkpoint_v2(db, "main", SQLITE_CHECKPOINT_TRUNCATE, NULL, NULL);
+  if (rc != SQLITE_OK) {
+    sqlite3_log(rc, "[rekey]checkpoint failed: %d", rc);
+    goto cleanup;
+  }
+  codecSql = GenerateSQLFromCodeConfig(&rekeyConfig->rekeyCfg, 0);
+  if (codecSql != NULL) {
+    rc = sqlite3_exec(db, codecSql, NULL, NULL, NULL);
+    sqlite3_free(codecSql);
+    if (rc != SQLITE_OK) {
+      sqlite3_log(rc, "[rekey]PRAGMA rekey cfg failed: %d", rc);
+      goto cleanup;
+    }
+  }
+  *rekeyDb = db;
+  return rc;
+cleanup:
+  if (db) sqlite3_close(db);
+  return rc;
+}
+
+int sqlite3_rekey_v3(CodecRekeyConfig *rekeyConfig)
+{
+  sqlite3 *db = NULL;
+  int rc = RekeyPrepare(rekeyConfig, &db);
+  if (rc != SQLITE_OK) {
+    return rc;
+  }
+  return sqlite3_rekey_v3_inner(db, "main", rekeyConfig->rekeyCfg.pKey, rekeyConfig->rekeyCfg.nKey);
+}
+
 void sqlite3_activate_see(const char* zPassPhrase){
   return;
 }
@@ -256232,20 +256930,116 @@ CODEC_STATIC void sqlite3CodecReturnPragmaResult(Parse *parse, const char *label
   return;
 }
 
+CODEC_STATIC int sqlite3CodecPragmaError(Parse *parse, int rc){
+  if (rc != SQLITE_OK) {
+    parse->nErr++;
+    parse->rc = rc;
+  }
+  return 1;
+}
+
+CODEC_STATIC int sqlite3CodecRekeyPragma(CodecParameter *rekeyParm, Parse *parse, const char *zLeft, const char *zRight)
+{
+  int rc = SQLITE_ERROR;
+  if(sqlite3StrICmp(zLeft, "codec_rekey_hmac_algo") == 0){
+    if(zRight){
+      int hmacAlgo = HmacName2Algo(zRight);
+      if (hmacAlgo == CIPHER_HMAC_ALGORITHM_INVALID) {
+        goto PRAGMA_ERROR;
+      }
+      sqlite3CodecSetDefaultAttachHmacAlgo(rekeyParm, hmacAlgo);
+      rekeyParm->reserveSize = sqlite3CodecGetHmacReserveSize(rekeyParm);
+    }else{
+      const char *hmacName = Algo2HmacName(rekeyParm->hmacAlgo);
+      if (hmacName == NULL) {
+        goto PRAGMA_ERROR;
+      }
+      sqlite3CodecReturnPragmaResult(parse, "codec_rekey_hmac_algo", hmacName);
+    }
+  }else if(sqlite3StrICmp(zLeft, "codec_rekey_kdf_algo") == 0){
+    if(zRight){
+      int kdfAlgo = KdfName2Algo(zRight);
+      if (kdfAlgo == CIPHER_KDF_ALGORITHM_INVALID) {
+        goto PRAGMA_ERROR;
+      }
+      sqlite3CodecSetDefaultAttachKdfAlgo(rekeyParm, kdfAlgo);
+    }else{
+      const char *kdfName = Algo2KdfName(rekeyParm->kdfAlgo);
+      if (kdfName == NULL) {
+        goto PRAGMA_ERROR;
+      }
+      sqlite3CodecReturnPragmaResult(parse, "codec_rekey_kdf_algo", kdfName);
+    }
+  }else if(sqlite3StrICmp(zLeft, "codec_rekey_page_size") == 0){
+    if(zRight){
+      int pgSz = atoi(zRight);
+      if (!CodecPageSizeValid(pgSz)) {
+        goto PRAGMA_ERROR;
+      }
+      sqlite3CodecSetDefaultAttachPageSize(rekeyParm, pgSz);
+    } else {
+      char *pageSize = sqlite3_mprintf("%d", rekeyParm->pageSize);
+      if (pageSize != NULL) {
+        sqlite3CodecReturnPragmaResult(parse, "codec_rekey_page_size", pageSize);
+        sqlite3_free(pageSize);
+      }
+    }
+  }else if(sqlite3StrICmp(zLeft, "codec_rekey_cipher") == 0){
+    if(zRight){
+      if(sqlite3CodecSetDefaultAttachCipher(rekeyParm, zRight) != SQLITE_OK){
+        goto PRAGMA_ERROR;
+      }
+      rekeyParm->reserveSize = sqlite3CodecGetHmacReserveSize(rekeyParm);
+    }else{
+      void *sslCipher = opensslGetCipher(sqlite3CodecGetDefaultAttachCipher(rekeyParm));
+      if(sslCipher == NULL){
+        goto PRAGMA_ERROR;
+      }
+      sqlite3CodecReturnPragmaResult(parse, "codec_rekey_cipher", opensslGetCipherName(sslCipher));
+    }
+  }else if(sqlite3StrICmp(zLeft, "codec_rekey_kdf_iter") == 0){
+    if(zRight){
+      if(sqlite3CodecSetDefaultAttachKdfIter(rekeyParm, atoi(zRight)) != SQLITE_OK){
+        goto PRAGMA_ERROR;
+      }
+    }else{
+      char *iter = sqlite3_mprintf("%d", rekeyParm->kdfIter);
+      if(iter != NULL){
+        sqlite3CodecReturnPragmaResult(parse, "codec_rekey_kdf_iter", iter);
+        sqlite3_free(iter);
+      }
+    }
+  } else {
+    goto PRAGMA_ERROR;
+  }
+  return 1;
+PRAGMA_ERROR:
+  return sqlite3CodecPragmaError(parse, rc);
+}
+
 // Each configuration setting operation should be done before read/write DB file or there might be some error.
 int sqlite3CodecPragma(sqlite3 *db, int iDb, Parse *parse, const char *zLeft, const char *zRight){
   Btree *p = db->aDb[iDb].pBt;
   if(p == NULL){
     return 0;
   }
+  if(sqlite3_strnicmp(zLeft, "codec_", sizeof("codec_") - 1) != 0 &&
+    sqlite3_strnicmp(zLeft, "cipher_", sizeof("cipher_") - 1) != 0){
+    return 0;
+  }
+  int rc = SQLITE_ERROR;
   CodecContext *ctx = (CodecContext *)(p->pBt->pPager->pCodec);
 #ifdef SQLITE_CODEC_ATTACH_CHANGED
-  CodecParameter *parm = &db->codecParm;
+  CodecParameter *parm = &db->codecParm[0];
   if(sqlite3StrICmp(zLeft, "cipher_default_attach_cipher") == 0 && zRight != NULL){
-    (void)sqlite3CodecSetDefaultAttachCipher(parm, zRight);
+    if(sqlite3CodecSetDefaultAttachCipher(parm, zRight) != SQLITE_OK){
+      goto CODEC_PRAGMA_ERROR;
+    }
     return 1;
   }else if(sqlite3StrICmp(zLeft, "cipher_default_attach_kdf_iter") == 0 && zRight != NULL){
-    (void)sqlite3CodecSetDefaultAttachKdfIter(parm, atoi(zRight));
+    if(sqlite3CodecSetDefaultAttachKdfIter(parm, atoi(zRight)) != SQLITE_OK){
+      goto CODEC_PRAGMA_ERROR;
+    }
     return 1;
   }else if( sqlite3StrICmp(zLeft, "cipher_default_attach_hmac_algo")==0 && zRight!=NULL ){
     /*
@@ -256262,7 +257056,7 @@ int sqlite3CodecPragma(sqlite3 *db, int iDb, Parse *parse, const char *zLeft, co
       sqlite3CodecSetDefaultAttachHmacAlgo(parm, CIPHER_HMAC_ALGORITHM_SHA512);
       sqlite3CodecSetDefaultAttachKdfAlgo(parm, CIPHER_KDF_ALGORITHM_SHA512);
     }else{
-      return 0;
+      goto CODEC_PRAGMA_ERROR;
     }
     return 1;
   }else if( sqlite3StrICmp(zLeft, "cipher_default_attach_kdf_algo")==0 && zRight!=NULL ){
@@ -256273,7 +257067,7 @@ int sqlite3CodecPragma(sqlite3 *db, int iDb, Parse *parse, const char *zLeft, co
     }else if( sqlite3_stricmp(zRight, CIPHER_KDF_ALGORITHM_NAME_SHA512)==0 ){
       sqlite3CodecSetDefaultAttachKdfAlgo(parm, CIPHER_KDF_ALGORITHM_SHA512);
     }else{
-      return 0;
+      goto CODEC_PRAGMA_ERROR;
     }
     return 1;
   }else if( sqlite3StrICmp(zLeft, "cipher_default_attach_page_size")==0 && zRight!=NULL ){
@@ -256281,11 +257075,17 @@ int sqlite3CodecPragma(sqlite3 *db, int iDb, Parse *parse, const char *zLeft, co
     return 1;
   }
 #endif /* SQLITE_CODEC_ATTACH_CHANGED */
+  if(sqlite3_strnicmp(zLeft, "codec_rekey_", sizeof("codec_rekey_") - 1) == 0){
+    return sqlite3CodecRekeyPragma(&db->codecParm[1], parse, zLeft, zRight);
+  }
   if(ctx == NULL){
     return 0;
   }
   if(sqlite3StrICmp(zLeft, "codec_cipher") == 0){
     if(zRight){
+      if(CipherName2CipherId(zRight) == CIPHER_ID_INVALID){
+        goto CODEC_PRAGMA_ERROR;
+      }
       sqlite3_mutex_enter(db->mutex);
       (void)sqlite3CodecSetCodecConstant(ctx->readCtx, zRight);
       (void)sqlite3CodecSetHmacAlgorithm(ctx->readCtx, ctx->readCtx->codecConst.hmacAlgo);
@@ -256332,7 +257132,7 @@ int sqlite3CodecPragma(sqlite3 *db, int iDb, Parse *parse, const char *zLeft, co
         (void)sqlite3CodecSetKdfAlgorithm(ctx->writeCtx, CIPHER_KDF_ALGORITHM_SHA512);
       }else{
         sqlite3_mutex_leave(db->mutex);
-        return 0;
+        goto CODEC_PRAGMA_ERROR;
       }
       sqlite3BtreeSetPageSize(p, ctx->readCtx->codecConst.cipherPageSize, ctx->readCtx->codecConst.reserveSize, 0);
       sqlite3_mutex_leave(db->mutex);
@@ -256359,7 +257159,7 @@ int sqlite3CodecPragma(sqlite3 *db, int iDb, Parse *parse, const char *zLeft, co
         (void)sqlite3CodecSetKdfAlgorithm(ctx->writeCtx, CIPHER_KDF_ALGORITHM_SHA512);
       }else{
         sqlite3_mutex_leave(db->mutex);
-        return 0;
+        goto CODEC_PRAGMA_ERROR;
       }
       sqlite3BtreeSetPageSize(p, ctx->readCtx->codecConst.cipherPageSize, ctx->readCtx->codecConst.reserveSize, 0);
       sqlite3_mutex_leave(db->mutex);
@@ -256375,10 +257175,10 @@ int sqlite3CodecPragma(sqlite3 *db, int iDb, Parse *parse, const char *zLeft, co
   }else if( sqlite3StrICmp(zLeft, "codec_page_size")==0 ){
     if(zRight){
       sqlite3_mutex_enter(db->mutex);
-      int rc = sqlite3CodecSetCipherPageSize(ctx, atoi(zRight));
+      rc = sqlite3CodecSetCipherPageSize(ctx, atoi(zRight));
       if (rc != SQLITE_OK){
         sqlite3_mutex_leave(db->mutex);
-        return 0;
+        goto CODEC_PRAGMA_ERROR;
       }
       sqlite3BtreeSetPageSize(p, ctx->readCtx->codecConst.cipherPageSize, ctx->readCtx->codecConst.reserveSize, 0);
       sqlite3_mutex_leave(db->mutex);
@@ -256389,33 +257189,12 @@ int sqlite3CodecPragma(sqlite3 *db, int iDb, Parse *parse, const char *zLeft, co
         sqlite3_free(pageSize);
       }
     }
-  }else if(sqlite3StrICmp(zLeft, "codec_rekey_hmac_algo") == 0){
-    if(zRight){
-      sqlite3_mutex_enter(db->mutex);
-      if( sqlite3_stricmp(zRight, CIPHER_HMAC_ALGORITHM_NAME_SHA1)==0 ){
-        ctx->writeCtx->codecConst.rekeyHmacAlgo = CIPHER_HMAC_ALGORITHM_SHA1;
-      }else if( sqlite3_stricmp(zRight, CIPHER_HMAC_ALGORITHM_NAME_SHA256)==0 ){
-        ctx->writeCtx->codecConst.rekeyHmacAlgo = CIPHER_HMAC_ALGORITHM_SHA256;
-      }else if( sqlite3_stricmp(zRight, CIPHER_HMAC_ALGORITHM_NAME_SHA512)==0 ){
-        ctx->writeCtx->codecConst.rekeyHmacAlgo = CIPHER_HMAC_ALGORITHM_SHA512;
-      }else{
-        sqlite3_mutex_leave(db->mutex);
-        return 0;
-      }
-      sqlite3_mutex_leave(db->mutex);
-    }else{
-      if( ctx->writeCtx->codecConst.rekeyHmacAlgo==CIPHER_HMAC_ALGORITHM_SHA1 ){
-        sqlite3CodecReturnPragmaResult(parse, "codec_rekey_hmac_algo", CIPHER_HMAC_ALGORITHM_NAME_SHA1);
-      }else if( ctx->writeCtx->codecConst.rekeyHmacAlgo==CIPHER_HMAC_ALGORITHM_SHA256 ){
-        sqlite3CodecReturnPragmaResult(parse, "codec_rekey_hmac_algo", CIPHER_HMAC_ALGORITHM_NAME_SHA256);
-      }else if( ctx->writeCtx->codecConst.rekeyHmacAlgo==CIPHER_HMAC_ALGORITHM_SHA512 ){
-        sqlite3CodecReturnPragmaResult(parse, "codec_rekey_hmac_algo", CIPHER_HMAC_ALGORITHM_NAME_SHA512);
-      }
-    }
   }else{
-    return 0;
+    goto CODEC_PRAGMA_ERROR;
   }
   return 1;
+CODEC_PRAGMA_ERROR:
+  return sqlite3CodecPragmaError(parse, rc);
 }
 
 CODEC_STATIC int sqlite3CodecExportMetadata(sqlite3 *db, const char *dbName, const char *metaName){
@@ -257606,24 +258385,6 @@ CHK_RESTORE_OUT:
   return rc;
 }
 
-static inline u8 IsConnectionValidForCheck(Pager *pPager)
-{
-#if SQLITE_OS_UNIX
-  u8 checkFileId = Sqlite3GetCheckFileId(pPager->pVfs);
-  if( checkFileId==0 ){
-    return 0;
-  }
-  unixFile *fd = Sqlite3GetUnixFile(pPager->fd, checkFileId);
-  // unix and only one connection exist
-  if (fd == NULL || fd->pInode == NULL || fd->pInode->nRef != (checkFileId==SQLITE_CHECK_FILE_ID_COMPRESS ? 2 : 1)) {
-    return 0;
-  }
-  return 1;
-#else
-  return 0;
-#endif /* SQLITE_OS_UNIX */
-}
-
 static int MetaDwrOpenAndCheck(Btree *pBt)
 {
   Pager *pPager = pBt->pBt->pPager;
@@ -257711,6 +258472,32 @@ static inline int OsGetTid(void)
 #endif
 }
 
+static u8 IsOnlyOneConnection(Pager *pPager)
+{
+#if SQLITE_OS_UNIX
+  u8 checkFileId = Sqlite3GetCheckFileId(pPager->pVfs);
+  if( checkFileId==0 ){
+    return 0;
+  }
+  unixFile *fd = Sqlite3GetUnixFile(pPager->fd, checkFileId);
+  if (fd == NULL || fd->pInode == NULL) {
+    sqlite3_log(SQLITE_WARNING_DUMP, "Check connection go wrong");
+    return 0;
+  }
+  unixInodeInfo *pInode = fd->pInode;
+  sqlite3_mutex_enter(pInode->pLockMutex);
+  // unix and only one connection exist
+  if (pInode->nRef != (checkFileId==SQLITE_CHECK_FILE_ID_COMPRESS ? 2 : 1)) {
+    sqlite3_mutex_leave(pInode->pLockMutex);
+    return 0;
+  }
+  sqlite3_mutex_leave(pInode->pLockMutex);
+  return 1;
+#else
+  return 0;
+#endif /* SQLITE_OS_UNIX */
+}
+
 static void ResetLockStatus(void)
 {
   (void)memset(&g_lockStatus, 0, sizeof(g_lockStatus));
@@ -259118,6 +259905,11 @@ struct sqlite3_api_routines_extra {
   int (*key_v2)(sqlite3*,const char*,const void*,int);
   int (*rekey)(sqlite3*,const void*,int);
   int (*rekey_v2)(sqlite3*,const char*,const void*,int);
+#ifdef SQLITE_HAS_CODEC
+  int (*rekey_v3)(CodecRekeyConfig *);
+#else
+  void *dymmyRekeyV3Func;
+#endif
   int (*is_support_binlog)(void);
   int (*replay_binlog)(sqlite3*, sqlite3*);
   int (*clean_binlog)(sqlite3*, BinlogFileCleanModeE);
@@ -259137,11 +259929,13 @@ static const sqlite3_api_routines_extra sqlite3ExtraApis = {
   sqlite3_key_v2,
   sqlite3_rekey,
   sqlite3_rekey_v2,
+  sqlite3_rekey_v3,
 #else
   0,
   0,
   0,
   0,
+  0,
 #endif /* SQLITE_HAS_CODEC */
 #ifdef SQLITE_ENABLE_BINLOG
   sqlite3_is_support_binlog,
-- 
2.28.0.windows.1

